# Web-appendix-TMLE-causal-inference-survival-analysis
* Web appendix 

This is the web-appendix to our manuscript entitled /Targeted/
/maximum likelihood estimation for causal inference in survival and
competing risks analysis/. \\

We provide =R= code to apply our current implementations of TMLE for
estimation of causal parameters in survival and competing risks
settings; this includes the iterative and the one-step targeting
procedures as well as super learning to combine different Cox
regression models or variations over the highly adaptive
lasso (HAL) estimator. \\

Although the current implementations can be applied to new data
settings, we emphasize that our implementations remain to be made into
a more user-friendly software package. Current and future work is
involved with this.

** Overview

We consider as an example the analysis of a particular dataset as well
as a simulated version resembling it. The point of looking at the
simulated version is that we know the truth, both in terms of the
underlying statistical model and the true values of the considered
target parameters.\\

We will go through the following:

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#data-example][Presentation of the data example]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#simulated-version-of-the-colon-data][Simulated version of the data example]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#true-values-of-target-parameters-box-1][Computing true values of target parameters]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#targeting-hazard-estimators-for-real-valued-parameter][Targeting hazard estimators for real-valued parameter]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#targeting-hazard-estimators-for-multivariate-parameter][Targeting hazard estimators for multivariate parameter]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#initial-estimation-for-analysis-of-the-colon-data][On the initial estimation for analysis of the colon data]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#analysis-of-the-colon-survival-data][Analysis of the colon survival data]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-fixed-time-point][Fixed time-point]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-multiple-time-points][Multiple time-points]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#analysis-of-the-colon-competing-risks-data][Analysis of the colon competing risks data]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-fixed-time-point-1][Fixed time-point]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-multiple-time-points-1][Multiple time-points]]

*Note:* To run any of the code chunks below you need to load the
following =R= script:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports none  :session *R* :cache yes  
setwd("~/research/TMLE-from-2020june/survival-baseline/Web-appendix-TMLE-causal-inference-survival-analysis/")
#+END_SRC

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/load.R")  
#+END_SRC

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports none  :session *R* :cache yes  
path.to.file <- "~/research/TMLE-from-2020june/survival-baseline/Web-appendix-TMLE-causal-inference-survival-analysis"
#+END_SRC

** Data example 

In our manuscript we use the publicly available dataset =colon= from
the =survival= package in =R= for demonstration. These are data
from a trial on adjuvant chemotherapy for colon cancer, comparing
levamisole treatment against levamisole treatment combined with
fluorouracil (a chemotherapy agent) against no treatment. 

The raw data available in R consist of two rows per subject:
one for cancer recurrence and one for death. This allows us to work
with the data in two different forms, for two different purposes, as
follows:

- Survival outcome data: :: We consider treatment effect estimation in
     the setting where the event of interest is all-cause mortality
     and there are no competing causes.
- Competing risks data: :: We consider treatment effect estimation in
     the setting with two competing causes being cancer recurrence and
     death.

In this script we load the =colon= data and create the two datasets
above:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/preprocess.colon.data.R")     
#+END_SRC    

Number of subjects assigned to each treatment (=rx=) option:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
colon.surv[, table(rx)] 
#+END_SRC 

: rx
:     Obs     Lev Lev+5FU 
:     305     294     289

Number of events in the survival data (=colon.surv=): 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
out <- cbind(colon.surv[, .N, by="event"],   
             colon.surv[, max(time), by="event"][, max.follow.up:=V1][, -c("event", "V1"), with=FALSE])
colnames(out) <- c("event", "N", "max follow-up")
out    
#+END_SRC    

:    event   N max follow-up
: 1:     1 430          2910
: 2:     0 458          3329

Number of events in the competing risks data (=colon.cr=):

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
out <- cbind(colon.cr[order(event)][, .N, by="event"],   
             colon.cr[order(event)][, max(time), by="event"][, max.follow.up:=V1][, -c("event", "V1"), with=FALSE]) 
colnames(out) <- c("event", "N", "max follow-up")
out 
#+END_SRC    

:  
:   event   N max follow-up
: 1:     0 405          3329
: 2:     1 446          2695
: 3:     2  37          2789

Note that for both datasets we simply removed observations with
missing covariates.\\


#+Begin_Src latex :file "~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/figures/graph-multistate-colon.pdf" :packages '(("" "tikz")) :border 1em :results raw :exports none
  % Define block styles   
  \usetikzlibrary{shapes,arrows,snakes} 
  \tikzstyle{astate} = [circle, draw, text centered, font=\footnotesize]
  \tikzstyle{bstate} = [text centered, font=\footnotesize]
  \tikzstyle{cstate} = [text centered, font=\footnotesize,fill=gray!20, draw=none, rectangle, rounded corners]
  \tikzstyle{rstate} = [circle, draw, text centered, font=\footnotesize, minimum size=1.3cm]
  \tikzstyle{r2state} = [circle, draw, text centered, font=\footnotesize, minimum size=1.8cm]
  \tikzstyle{r1state} = [regular polygon,regular polygon sides=9, fill=gray!20, draw, text centered, font=\footnotesize, minimum size=0.05cm]
  \tikzstyle{r3state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, font=\footnotesize]
  \tikzstyle{r3stategray} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, font=\footnotesize, color=gray] 
  \tikzstyle{r4state} = [draw,ellipse,ellipse left angle=70,trapezium right angle=-70,fill=white!20,minimum height=0.6cm, font=\footnotesize]
  \tikzstyle{r33state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70,minimum height=0.7cm, font=\footnotesize]
  \tikzstyle{r333state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70,minimum height=0.3cm, font=\footnotesize]
  \tikzstyle{r3333state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, rounded corners, minimum height=0.5cm, font=\footnotesize]
  \tikzstyle{r5state} = [draw, star, star points=10, ]

  \begin{tikzpicture}[->,>=stealth', shorten >=1pt, auto, node distance=2.8cm, semithick, font=\sffamily]
   \node [r3state] (0) at (-0.5,0.2) {};
    \node [bstate, left] (0a) at (-0.7,0.2) {\scriptsize initial state};
    \node [r3state] (00) at (1.0,0.5) {1};
 %   \node [r3state] (1) at (1.0,0.2) {1}; 
    \node [bstate, right] (1a) at (1.2, 0.5) {\scriptsize cancer relapse};
    \node [r3state] (3) at (1.0,-0.1) {2}; 
    \node [bstate, right] (3a) at (1.2, -0.1) {\scriptsize relapse-free death}; 
    \path (0) edge node {} (00) 
      %    (0) edge node {} (1)
        %  (0) edge node {} (2)  
          (0) edge node {} (3)  
          (0c) edge [dashed, white] node {} (a0) 
  \end{tikzpicture} 
#+end_src




[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]



** Simulated version of the =colon= data

The following script sets up simple functionality to create simulated
versions of the =colon= data:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/synthesize.colon.data.R")       
#+END_SRC    

To create a simulated version of the survival data, we run code as
follows:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
#-- fit models to data;   
fit.colon <- fit.colon.fun(
    formula.1=Surv(time, event==1)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.0=Surv(time, event==0)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.treat=rx~sex+age+nodes+differ+obstruct+perfor+adhere+extent+surg,
    d=colon.surv)   
#-- here we simulate data (fixed seed);  
set.seed(15)   
(sim.colon.surv <- synthesize.colon.fun(fit.colon=fit.colon, d=colon.surv, name.treat="rx", event.name="event")) 
#+END_SRC   

#+begin_example
     sex age obstruct perfor adhere nodes differ extent surg rx.num      rx      time event
  1:   0  69        0      0      0    12      2      3    0      3 Lev+5FU  634.0321     1
  2:   0  48        0      0      0     1      2      3    0      2     Lev  889.8198     1
  3:   0  42        0      0      0     6      1      3    0      2     Lev  670.7178     1
  4:   0  78        0      0      0     3      2      3    0      3 Lev+5FU 1922.5082     1
  5:   1  49        0      0      0    10      2      3    0      1     Obs 1830.0520     1
 ---                                                                                       
884:   0  75        0      0      0     2      3      3    0      2     Lev  860.8502     1
885:   0  76        0      0      0     1      2      3    0      1     Obs 1527.2115     1
886:   0  51        0      0      0     4      2      3    1      3 Lev+5FU 2665.0731     0
887:   0  63        0      0      0     5      2      3    1      3 Lev+5FU 2577.7704     0
888:   1  51        1      0      0     4      2      3    1      2     Lev 2932.9771     1
#+end_example

The hazards are generated from Weibull distributions with functional
form as specified by the =formula.1= (for the hazard of the event
distribution) and =formula.0= (for the hazard of the censoring
distribution) arguments; note that for both we simply include main
effects of treatment and all covariates. The treatment variable
(called =rx=) is generated from the model including, as well, all main
effects of covariates. The parameters for each model are estimated
based on the observed colon data with the function =fit.colon.fun= and
then used to generate the simulated data with
=synthesize.colon.fun=. \\


To create a simulated version of the competing risks data, we
similarly run code as follows:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
#-- fit models to data; 
fit.colon.cr <- fit.colon.fun(      
    formula.1=Surv(time, event==1)~rx+sex+differ+age+nodes.squared+obstruct+perfor+adhere+extent+surg+rx*sex+rx*perfor+rx*age,
    formula.2=Surv(time, event==2)~rx+sex+nodes+differ+age+obstruct+adhere+extent+surg,
    formula.0=Surv(time, event==0)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.treat=rx~sex+age+nodes+differ+obstruct+perfor+adhere+extent+surg,
    d=colon.cr)  
#-- here we simulate data (fixed seed); 
set.seed(31)      
(sim.colon.cr <- synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event"))
#+END_SRC   

#+begin_example
     sex age obstruct perfor adhere nodes differ extent surg nodes.squared rx.num      rx      time event
  1:   0  55        1      0      0     4      1      3    0            16      2     Lev 2590.1288     0
  2:   0  64        0      0      0     1      2      3    0             1      2     Lev  862.2267     1
  3:   1  63        0      0      0     2      3      3    0             4      1     Obs  244.6612     1
  4:   1  67        1      0      0     1      2      3    1             1      3 Lev+5FU 1446.1525     1
  5:   0  45        0      0      0     3      2      3    0             9      3 Lev+5FU 3224.6467     0
 ---                                                                                                     
884:   0  71        0      0      0    20      2      3    0           400      3 Lev+5FU 2117.5456     0
885:   0  34        1      0      0     3      1      3    0             9      1     Obs 2314.8256     0
886:   1  66        0      0      0     2      2      4    0             4      1     Obs  488.2843     0
887:   1  50        1      0      1     1      2      3    0             1      2     Lev  127.1821     1
888:   1  42        1      0      0     5      2      3    0            25      1     Obs  525.6158     1
#+end_example

Here the cause-specific hazards are generated from Weibull
distributions with functional forms as specified by the =formula.1=
and =formula.2= arguments. As before, =formula.0= specifies the hazard
of the censoring distribution.  Note that we specified the model for
the cause-1 specific hazard with a squared effect of =nodes= and
interactions between treatment and three of the covariates.

[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** True values of target parameters

To compute the approximations to the true values of the target
parameters for the simulated competing risks data, we run the
following code:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
true.a0 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=0, tau=tt*365.25)) 
true.a1 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=1, tau=tt*365.25))   
true.a2 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=2, tau=tt*365.25))
#+END_SRC   


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Absolute risks under treatment=Obs:")  
tab0 <- rbind(sapply(true.a0, function(x) x["F1"]), 
              sapply(true.a0, function(x) x["F2"])) 
rownames(tab0) <- c("F1", "F2") 
colnames(tab0) <- paste0((1:10)/2)
print(tab0)
message("")
message("Absolute risks under treatment=Lev:") 
tab1 <- rbind(sapply(true.a1, function(x) x["F1"]), 
              sapply(true.a1, function(x) x["F2"]))
rownames(tab1) <- c("F1", "F2") 
colnames(tab1) <- paste0((1:10)/2) 
print(tab1)
message("")
message("Absolute risks under treatment=Lev+5FU:") 
tab2 <- rbind(sapply(true.a2, function(x) x["F1"]), 
              sapply(true.a2, function(x) x["F2"]))
rownames(tab2) <- c("F1", "F2") 
colnames(tab2) <- paste0((1:10)/2)
print(tab2)
#+END_SRC    

#+begin_example
Absolute risks under treatment=Obs:
 
       0.5        1      1.5        2      2.5        3      3.5       4      4.5        5
F1 0.146465 0.227907 0.288342 0.339962 0.382316 0.419372 0.452278 0.48266 0.508024 0.532319
F2 0.000400 0.001145 0.002186 0.003464 0.004639 0.005960 0.007595 0.00901 0.010475 0.011990

Absolute risks under treatment=Lev:
 
       0.5        1      1.5        2      2.5        3      3.5        4      4.5        5
F1 0.137236 0.212368 0.271814 0.320762 0.361983 0.397857 0.430558 0.459212 0.486208 0.509233
F2 0.000235 0.000755 0.001475 0.002178 0.003173 0.004224 0.005209 0.006190 0.007314 0.008595

Absolute risks under treatment=Lev+5FU:
 
       0.5        1      1.5        2      2.5        3      3.5        4      4.5        5
F1 0.088497 0.139775 0.179475 0.214357 0.244999 0.272068 0.296521 0.318285 0.339306 0.357575
F2 0.000180 0.000538 0.001043 0.001834 0.002531 0.003325 0.004253 0.005287 0.006230 0.007313
#+end_example


We see for example that the average treatment effect of levamisole
    treatment compared to no treatment on the cause-one specific
    absolute risk beyond three years is:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Average treatment effect of levamisole compared to no treatment:") 
round(as.numeric(true.a1[(1:10)/2==3][[1]]["F1"] - true.a0[(1:10)/2==3][[1]]["F1"]),4) 
message("")
message("Average treatment effect of levamisole plus fluorouracil compared to no treatment:")  
round(as.numeric(true.a2[(1:10)/2==3][[1]]["F1"] - true.a0[(1:10)/2==3][[1]]["F1"]),4)
#+END_SRC   

: Average treatment effect of levamisole compared to no treatment:
: [1] -0.0215
: 
: Average treatment effect of levamisole plus fluorouracil compared to no treatment:
: [1] -0.1473


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
library(xtable)
tab0 <- rbind(sapply(true.a0, function(x) x["F1"]), 
              sapply(true.a0, function(x) x["F2"])) 
rownames(tab0) <- c("F1", "F2") 
colnames(tab0) <- paste0((1:10)/2)
print(xtable(tab0, align=rep("c", length(true.a0)+1), digits=3)) 

tab1 <- rbind(sapply(true.a1, function(x) x["F1"]), 
              sapply(true.a1, function(x) x["F2"]))
rownames(tab1) <- c("F1", "F2")  
colnames(tab1) <- paste0((1:10)/2) 
print(xtable(tab1, align=rep("c", length(true.a1)+1), digits=3)) 

tab2 <- rbind(sapply(true.a2, function(x) x["F1"]), 
              sapply(true.a2, function(x) x["F2"]))
rownames(tab2) <- c("F1", "F2") 
colnames(tab2) <- paste0((1:10)/2)
print(xtable(tab2, align=rep("c", length(true.a2)+1), digits=3)) 
#+END_SRC    

The approximations above were obtained by simulating a large dataset
(n = 1e6) from each counterfactual scenario (with no censoring and
setting A = 0,1,2 for all subjects) and computing the sample average
of the outcome indicator at the time-horizon of interest.


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Targeting hazard estimators for real-valued parameter

We here show the code to apply our TMLE function to the simulated data
to target the real-valued parameter being the absolute risk of cancer
relapse after 3 years of follow-up under treatment with levamisole
plus fluorouracil. \\

Note that we simply use a Cox regression including main effects of all
covariates for initial estimation of each cause-specific hazards and
also for the hazard of censoring (specified in the =estimation=
argument, with list elements for each hazard). This means that the Cox
model is misspecified for the cause-1 specific hazard. To estimate the
probability distribution of treatment (specified in the argument
=treat.model=), we similarly include main effects of all
covariates. To get the treatment-specific absolute risk of cancer
relapse under levamisole plus fluorouracil treatment we set the
argument =treat.effect= to =Lev+5FU= and the argument =target= to
=1=. We specify the time-horizon by =tau= and note that the time
variable of the data is measured in days. \\

The function returns the initial (untargeted) estimate for the target
parameter, the Kaplan-Meier estimate and the targeted estimate along
with its standard error computed based on the efficient influence
function.


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.Lev5FU.3yrs <- 
     contmle(sim.colon.cr,  
             estimation=list("relapse"=list(fit="cox",
                                            model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                             "death"=list(fit="cox",
                                          model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                             "cens"=list(fit="cox",
                                         model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                             ),
             treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
             treat.effect="Lev+5FU",   
             output.km=TRUE,
             target=1,
             tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.Lev5FU.3yrs
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888


$tmle
$tmle$F1
         tau=1095.75
tmle.est 0.2778811  
tmle.se  0.02584953 
#+end_example

(Note that the function call produces a warning from fitting the Cox
model for the hazard of the censoring distribution because of the
variable =extent=). \\

Recall that the true value of this target parameter is:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
true.a2[(1:10)/2==3][[1]]["F1"]
#+END_SRC   

:       F1 
: 0.271716

Notice how the initial and the updated TMLE estimates each differ from
the true value; the initial estimator is biased due to the
misspecification of the cause-1 specific hazard, but this bias is
removed for the TMLE estimator due to its double robustness
properties.


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
(true.a0 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=0, tau=tt*365.25)))
(true.a1 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=1, tau=tt*365.25)))
(true.a2 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=2, tau=tt*365.25)))   
#+END_SRC   

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-parameter-axis.pdf" :exports none  :session *R* :width 12 :height 1.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    
pdat <- rbind(data.table(init=c(fit.tmle.F1.Lev5FU.3yrs$init$F1["init.est",]), 
                         tmle=unlist(c(fit.tmle.F1.Lev5FU.3yrs$tmle$F1["tmle.est",])),
                         true=c(true.a2["F1",]), 
                         parameter=c("Psi[1]^a"), 
                         treat=2))
 
pdat.melt <- melt(pdat, id.vars=c("treat", "parameter"))

pdat.melt[, min:=min(value)*0.98, by=c("treat", "parameter")]
pdat.melt[, max:=max(value)*1.02, by=c("treat", "parameter")]

pdat.melt[variable=="true", variable:="true value"]
pdat.melt[variable=="init", variable:="initial estimate"]
pdat.melt[variable=="tmle", variable:="TMLE estimate"]

ggplot(pdat.melt[treat==2 & parameter=="Psi[1]^a"]) + 
    theme_void(base_size=25) +  
    ylim(1.95, 2.05) +  
    geom_segment(aes(x=min, xend=max, y=treat, yend=treat), arrow=arrow(length=unit(0.3, "cm"))) +   
    geom_text(aes(x=value, y=treat-0.03, label=round(value, 4)), size=5) + 
    geom_point(aes(x=value, y=treat), shape=3, size=4) +
    geom_text(aes(x=value, y=treat+0.03, label=variable), size=6.0) + 
    scale_shape_manual(values=c(1, 8, 9)) + 
    labs(shape="") +  
    theme(legend.position="bottom")   
#+END_SRC    


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F1.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=1,
            output.mat="init", 
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F1.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=1,
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC    

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-tmle-update-colon-cr.pdf" :exports none  :session *R* :width 12 :height 8.5 :cache yes
i <- 1 
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause=paste0("hat(Lambda)['1,n']", "~'['*'id'*'='*", i, "*']'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz2*fit.cox2]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause=paste0("hat(Lambda)['2,n']", "~'['*'id'*'='*", i, "*']'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         ##init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, surv.t]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         ##updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, surv.t]),
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause=paste0("hat(S)['n']", "~'[population average]'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         ##init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, F1.t]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]), 
                         ##updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, F1.t]),
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause=paste0("hat(F)['1,n']", "~'[population average]'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))))

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause")) 

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"] 

pdat.melt[, cause.factor:=factor(cause, ordered=TRUE, levels=pdat.melt[, unique(cause)])]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          axis.text=element_text(size=12),
          legend.key.size=unit(3,"line")) + 
    ylab("") + 
    xlab("time (days)") +  
    labs(linetype="") + 
    facet_wrap(. ~ cause.factor, labeller=label_parsed, scales="free_y") + 
    geom_line(aes(x=time, y=value, linetype=variable))    
#+END_SRC    


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg", "nodes.squared",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))
fit.tmle.F1.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            hal.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,
            tau=3*365.25) 
tune.grid <- copy(fit.tmle.F1.Lev5FU.3yrs)
tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes.squared:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[order(cve)]
#+END_SRC   


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Targeting hazard estimators for multivariate parameter

We here show the code to apply our TMLE function to target the
multivariate parameter being the absolute risk of cancer relapse /and/
the absolute risk of relapse-free death after 3 years of follow-up
under treatment with levamisole plus fluorouracil. \\

The only change to the function call above is setting the argument
=target= to =1:2=. (When the argument =target= is multivariate, like
here, the one-step TMLE is applied per default; one could also specify
the argument =iterative= as =TRUE= to apply the iterative TMLE to
target the two absolute risk probabilities separately).

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            simultaneous.ci=TRUE,
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs 
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074

$init$F2
         tau=1095.75
init.est 0.012503259
init.se  0.007945622

$init$S
         tau=1095.75
init.est  0.68144137
init.se   0.02669174


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888

$km$F2
       tau=1095.75
km.est 0.014511430
km.se  0.007204259


$tmle
$tmle$F1
         tau=1095.75
tmle.est  0.27774955
tmle.se   0.02584448

$tmle$F2
         tau=1095.75
tmle.est 0.014375801
tmle.se  0.007923176

$tmle$S
         tau=1095.75
tmle.est  0.70787465
tmle.se   0.02660447


$convergenced.at.step
[1] 10

$q.max.95
     95% 
1.963704
#+end_example

The number found by =q.max.95= in the output is the 95% quantile used
to compute simultaneous confidence intervals. Notice that here this
number is very close to 1.96, so there will not be much difference
between the simultaneous and the marginal confidence intervals. \\

There are different technical options to how to run the one-step TMLE,
corresponding to different versions of weighted norms. Above we used
the unweighted norm (which is default), but if we instead specify the
argument =weighted.norm= as =Sigma=, we use the covariance weighted
norm which often leads to much faster convergence:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs  
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074

$init$F2
         tau=1095.75
init.est 0.012503259
init.se  0.007945622

$init$S
         tau=1095.75
init.est  0.68144137
init.se   0.02669174


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888

$km$F2
       tau=1095.75
km.est 0.014511430
km.se  0.007204259


$tmle
$tmle$F1
         tau=1095.75
tmle.est  0.27905720
tmle.se   0.02584936

$tmle$F2
         tau=1095.75
tmle.est  0.01516394
tmle.se   0.00791143

$tmle$S
         tau=1095.75
tmle.est  0.70577886
tmle.se   0.02660989


$convergenced.at.step
[1] 5

$q.max.95
     95% 
1.963361
#+end_example

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=2,
            output.mat="init", 
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=2,
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            output.mat="init",
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC  

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-update-colon-cr-treat2.pdf" :exports none  :session *R* :width 12 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   

i <- 1
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz1*fit.cox1],
                                       init.F2.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)],
                                             updated.F2.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause="hat(Lambda)['1,n']", 
                         parameter=c(rep("hat(Lambda)['1,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(Lambda)['1,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz2*fit.cox2],
                                       init.F2.Lev5FU.3yrs[id==i, chaz2*fit.cox2]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)],
                                             updated.F2.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause="hat(Lambda)['2,n']", 
                         parameter=c(rep("hat(Lambda)['2,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(Lambda)['2,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))))

pdat[, parameter:=paste0(parameter, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

rev.fun <- function(var) sapply(strsplit(var, ""), function(x) paste0(rev(x), collapse=""))

pdat.melt[, parameter.factor:=factor(parameter, ordered=TRUE, levels=rev.fun(sort(rev.fun(pdat.melt[, unique(parameter)]))))]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"), 
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(parameter.factor ~ ., labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("Iterative TMLE applied for separate targeting:")  
#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-update-colon-cr-treat2.pdf" :exports none  :session *R* :width 12 :height 3.9 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

i <- 1
pdat <- rbind(data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause="hat(Lambda)['1,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[id==i, chaz2*fit.cox2]),  
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause="hat(Lambda)['2,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))))

pdat[, cause:=paste0(cause, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(. ~ cause, labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("One-step TMLE applied for simultaneous targeting:")  
#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-update-colon-cr-treat2-averaged.pdf" :exports none  :session *R* :width 12 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   
 
i <- 1
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause="hat(S)['n']", 
                         parameter=c(rep("hat(S)['n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(S)['n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause="hat(F)['1,n']", 
                         parameter=c(rep("hat(F)['1,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(F)['1,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),
                         cause="hat(F)['2,n']", 
                         parameter=c(rep("hat(F)['2,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(F)['2,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))))

#pdat[, parameter:=paste0(parameter, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

rev.fun <- function(var) sapply(strsplit(var, ""), function(x) paste0(rev(x), collapse=""))

pdat.melt[, parameter.factor:=factor(parameter, ordered=TRUE, levels=rev.fun(sort(rev.fun(pdat.melt[, unique(parameter)]))))]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"), 
          strip.text.x=element_text(size=14),
          axis.text=element_text(size=12),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(parameter.factor ~ ., labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("Iterative TMLE applied for separate targeting:")  
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-update-colon-cr-treat2-averaged.pdf" :exports none  :session *R* :width 12 :height 3.9 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

i <- 1
pdat <- rbind(data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause="hat(S)['n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause="hat(F)['1,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),
                         cause="hat(F)['2,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))))

#pdat[, cause:=paste0(cause, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"),
          strip.text.x=element_text(size=14),
          axis.text=element_text(size=12),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(.~cause, labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("One-step TMLE applied for simultaneous targeting:")  
#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-parameter-axis.pdf" :exports none  :session *R* :width 12 :height 1.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    
pdat <- rbind(data.table(init=c(fit.tmle.F1.F2.Lev5FU.3yrs$init$F1["init.est",]), 
                         tmle=unlist(c(fit.tmle.F1.F2.Lev5FU.3yrs$tmle$F1["tmle.est",])),
                         true=c(true.a2["F1",]), 
                         parameter=c("Psi[1]^a"),  
                         treat=2))
 
pdat.melt <- melt(pdat, id.vars=c("treat", "parameter"))

pdat.melt[, min:=min(value)*0.98, by=c("treat", "parameter")]
pdat.melt[, max:=max(value)*1.02, by=c("treat", "parameter")]

pdat.melt[variable=="true", variable:="true value"]
pdat.melt[variable=="init", variable:="initial estimate"]
pdat.melt[variable=="tmle", variable:="TMLE estimate"]

ggplot(pdat.melt[treat==2 & parameter=="Psi[1]^a"]) + 
    theme_void(base_size=25) +  
    ylim(1.95, 2.05) +  
    geom_segment(aes(x=min, xend=max, y=treat, yend=treat), arrow=arrow(length=unit(0.3, "cm"))) +   
    geom_text(aes(x=value, y=treat-0.03, label=round(value, 4)), size=5) + 
    geom_point(aes(x=value, y=treat), shape=3, size=4) +
    geom_text(aes(x=value, y=treat+0.03, label=variable), size=6.0) + 
    scale_shape_manual(values=c(1, 8, 9)) + 
    labs(shape="") +  
    theme(legend.position="bottom")   
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]





** Initial estimation for analysis of the =colon= data

Now we consider the actual colon data (and not the simulated
version). For initial estimation of cause-specific hazards in all the
following analyses, we use will a super learner consisting of the Cox
models specified above as well as a selection of different HAL
estimators.\\

Here we specify a large number of different Cox models by including
and excluding different combinations of both main effects of
covariates and also a selection of interactions between treatment and
covariates:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results output :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))
head(sl.models)
#+END_SRC

#+begin_example
$cox.model.1
$cox.model.1[[1]]
Surv(time, event == 1) ~ rx
<environment: 0x55847c18b5a8>


$cox.model.2
$cox.model.2[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + surg + rx * age
<environment: 0x55847c24dba8>


$cox.model.3
$cox.model.3[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + surg + rx * sex
<environment: 0x55847cce1c58>


$cox.model.4
$cox.model.4[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + rx * age + rx * sex
<environment: 0x55847cd0a798>


$cox.model.5
$cox.model.5[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + surg + rx * age + rx * sex
<environment: 0x55847cd2f068>


$cox.model.6
$cox.model.6[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + extent + surg + rx * age + rx * sex
<environment: 0x55847cd56bd0>
#+end_example

For the HAL estimators we first select covariates and two-way
interactions with a pre-screening step which only includes main
effects a given covariate or a specific interaction term for which at
least one of the basis functions was given a non-zero coefficient. We
further use cross-validation to select the number of knot-points for
first order and second order basis functions.

[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]


** Analysis of the =colon= survival data




#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))

cox.hal.sl.event.Lev5FU.surv.3yrs <-  
    contmle(colon.surv,  
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            tau=3*365.25)
cox.hal.sl.cens.Lev5FU.surv.3yrs <-  
    contmle(colon.surv,  
            estimation=list("outcome"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox.hal.sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            tau=3*365.25)
#+END_SRC


#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-surv-initial-estimation-event.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.event.Lev5FU.surv.3yrs)    

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("nodes included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("nodes excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("nodes excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("differ \n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("differ \n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[nodes==1, min.cve:=min.cve-1.2]
tune.grid[!nodes & !differ, min.cve:=min.cve-1]
tune.grid[!nodes & differ, min.cve:=min.cve-7.5]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="extent included"]
tune.grid[extent==0, extent.label:="extent excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("extent excluded",
    #                                                "extent included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+8, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+8), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    




*** Target parameters evaluated at fixed time-point 

We here compute TMLE estimates of the survival probabilities evaluated
after 3 years of follow-up, using for initial estimation of the event
hazard the super learner of Cox and HAL estimators and for the
censoring hazard the Cox super learner: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.colon.surv.3yrs <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            treat.effect=treat,   
            output.km=TRUE, 
            tau=3*365.25)}) 
names(fit.colon.surv.3yrs) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.3yrs,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.3yrs", ".rds"))
#+END_SRC    

This gives the following estimates of the treatment-specific survival
probabilities:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
(fit.tmle <- do.call("cbind", lapply(1:length(fit.colon.surv.3yrs), function(jj) {
    fit.jj <- fit.colon.surv.3yrs[[jj]]
    out.jj <- fit.jj$tmle
    colnames(out.jj) <- names(fit.colon.surv.3yrs)[jj] 
    return(out.jj) 
}))) 
#+END_SRC    

:                 Lev    Lev+5FU        Obs
: tmle.est 0.36305673 0.25236697 0.33642019
: tmle.se  0.02658146 0.02523538 0.02552276

And the corresponding average treatment effects estimates:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Lev versus Obs:")
rbind(est=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"], 
      se=sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.lwr=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"]-1.96*sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.upr=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"]+1.96*sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2))
message("")
message("")
message("Lev+5FU versus Obs:")
rbind(est=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"],  
      se=sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.lwr=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"]-1.96*sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.upr=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"]+1.96*sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2)) 
#+END_SRC    

#+begin_example
Lev versus Obs:
 
             [,1]
est     0.02663654
se      0.03685085
ci.lwr -0.04559112
ci.upr  0.09886420


Lev+5FU versus Obs:
 
             [,1]
est    -0.08405322
se      0.03589200
ci.lwr -0.15440154
ci.upr -0.01370490
#+end_example



#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-fixed.pdf" :exports none  :session *R* :width 8 :height 2.8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- data.table(t(do.call("cbind", lapply(1:length(fit.colon.surv.3yrs), function(jj) {
    fit.jj <- fit.colon.surv.3yrs[[jj]] 
    out.jj <- fit.jj$tmle
    colnames(out.jj) <- names(fit.colon.surv.3yrs)[jj]  
    return(out.jj) 
}))))

pdat[, tmle.est:=1-tmle.est] 
pdat[, which:=names(fit.colon.surv.3yrs)]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, no:=1:.N]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,3.5),  
                       labels=unique(pdat$which)) +  
    xlab("TMLE estimate") + 
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-survival-fixed.pdf" :exports none  :session *R* :width 8 :height 2.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    

pdat <- data.table(which=c("Lev vs Obs", "Lev+5FU vs Obs"),  
                   tmle.est=sapply(c("Lev", "Lev+5FU"), function(xx) fit.colon.surv.3yrs[[xx]]$tmle["tmle.est",] -  
                                                                     fit.colon.surv.3yrs[["Obs"]]$tmle["tmle.est",]), 
                   tmle.se=sapply(c("Lev", "Lev+5FU"), function(xx) sqrt(fit.colon.surv.3yrs[[xx]]$tmle["tmle.se",]^2 +   
                                                                         fit.colon.surv.3yrs[["Obs"]]$tmle["tmle.se",]^2)))

pdat[, tmle.est:=-tmle.est]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]  
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, no:=1:.N]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(),  
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_vline(aes(xintercept=0), alpha=0.6, linetype="dotted") +  
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,2.5), 
                       labels=unique(pdat$which)) + 
    xlab("TMLE estimate") + 
    ggtitle("Average treatment effects") 
#+END_SRC    



[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Target parameters evaluated at multiple time-points 

We here compute TMLE estimates of the survival probabilities evaluated
at a grid of 50 equidistant follow-up time-points, using again for
initial estimation of the event hazard the super learner of Cox and
HAL estimators and for the censoring hazard the Cox super learner:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code  :results none  :session *R* :cache yes 
fit.colon.surv.50 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            verbose=TRUE,
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            output.km=TRUE, 
            tau=(1:50)/(5*2)*365.25)}) 
names(fit.colon.surv.50) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.50,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.50", "-Sigma", ".rds"))
#+END_SRC    


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.colon.surv.30 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            verbose=TRUE,
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            output.km=TRUE, 
            tau=(1:30)/(3*2)*365.25)}) 
names(fit.colon.surv.30) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.30,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.30", "-Sigma", ".rds"))
#+END_SRC    

The output from the function call gives the estimates across all 50 time-points: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.colon.surv.50
#+END_SRC    

#+begin_example
$Lev
$Lev$init
          tau=36.525   tau=73.05 tau=109.575   tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
init.est 0.002441160 0.006101782  0.00854173 0.020765756  0.02811661 0.03794407  0.04777289 0.06373565  0.07844220
init.se  0.003750105 0.005100677  0.00584979 0.008628898  0.01096702 0.01265811  0.01431191 0.01512074  0.01617945
         tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
init.est 0.09191717  0.10416956 0.12508943  0.14109186 0.15345030  0.15965864 0.17584326  0.19453643 0.20447376
init.se  0.01752515  0.01826645 0.01940065  0.02003166 0.02051309  0.02084436 0.02163978  0.02201982 0.02281128
         tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
init.est  0.22678923 0.24411526   0.2613783 0.26877007  0.27738702 0.28847295  0.30321037 0.31674244   0.3327249
init.se   0.02338619 0.02416896   0.0246855 0.02475717  0.02485885 0.02510351  0.02546944 0.02570604   0.0261109
         tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
init.est 0.33883891   0.34739636  0.35227630   0.35959078  0.3741762   0.38388337   0.3935384   0.40201891 0.41290834
init.se  0.02621035   0.02651245  0.02659269   0.02675189  0.0267916   0.02695521   0.0270325   0.02700035 0.02705336
         tau=1351.425 tau=1387.95 tau=1424.475  tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
init.est   0.41532400  0.42013762   0.42493110 0.4321129   0.43450476  0.43929001    0.4428795  0.4440728   0.44645994
init.se    0.02735187  0.02734683   0.02736946 0.0274059   0.02740596  0.02737451    0.0274811  0.0274816   0.02748317
         tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
init.est  0.45241549   0.45479537 0.45838172   0.46437207   0.4691711
init.se   0.02757364   0.02753352 0.02753867   0.02749363   0.0275061

$Lev$km
        tau=36.525   tau=73.05 tau=109.575   tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
km.est 0.003401361 0.006802721 0.010204082 0.020408163  0.03401361 0.04761905  0.05782313 0.06462585  0.07823129
km.se  0.003395571 0.004793861 0.005861194 0.008246143  0.01057154 0.01242001  0.01361267 0.01433911  0.01566129
       tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
km.est 0.09863946  0.10884354 0.12925170  0.13945578 0.14965986  0.15986395 0.17687075   0.1870748 0.20408163
km.se  0.01739005  0.01816371 0.01956549  0.02020371 0.02080537  0.02137354 0.02225299   0.0227436 0.02350512
       tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
km.est  0.22108844 0.24489796  0.26870748 0.27210884  0.27891156 0.28911565  0.30272109 0.31972789  0.34013605
km.se   0.02420212 0.02507967  0.02585305 0.02595559  0.02615495 0.02644001  0.02679483 0.02719931  0.02762994
       tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
km.est 0.34693878   0.36394558   0.3673469   0.38435374  0.3945578   0.40476190  0.41496599   0.41836735 0.42176871
km.se  0.02776065   0.02806026   0.0281156   0.02836988  0.0285048   0.02862671  0.02873579   0.02876932 0.02880145
       tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
km.est   0.42517007  0.42517007   0.43197279 0.43537415   0.43537415  0.43877551    0.4421976  0.4421976    0.4421976
km.se    0.02883217  0.02883217   0.02888944 0.02891599   0.02891599  0.02894115    0.0289663  0.0289663    0.0289663
       tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
km.est  0.44561971   0.44904181 0.44904181   0.45246391  0.45246391
km.se   0.02899003   0.02901235 0.02901235   0.02903328  0.02903328

$Lev$tmle
          tau=36.525   tau=73.05 tau=109.575   tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
tmle.est 0.003757236 0.007272788  0.01018106 0.021541296  0.03539735 0.04863277  0.06083531 0.06886260  0.08189733
tmle.se  0.003746768 0.005099187  0.00584841 0.008621882  0.01092911 0.01261966  0.01427483 0.01508261  0.01612320
         tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
tmle.est 0.10074102  0.11140924 0.13082325  0.14169728 0.15185338  0.16083479 0.17823228  0.18808948 0.20490406
tmle.se  0.01743686  0.01816945 0.01931229  0.01992864 0.02039711  0.02070756 0.02147738  0.02187976 0.02267506
         tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
tmle.est  0.22255972 0.24534966  0.26687125 0.26992638  0.27749133 0.28674033  0.30044823 0.31601197  0.33501990
tmle.se   0.02320232 0.02398411  0.02447557 0.02456396  0.02462255 0.02488626  0.02526783 0.02548142  0.02590005
         tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
tmle.est 0.34198438   0.35919081  0.36269766   0.37743987 0.38699869   0.39755510  0.40670917   0.40977685 0.41411741
tmle.se  0.02598942   0.02627714  0.02637293   0.02651161 0.02655609   0.02673458  0.02681413   0.02677857 0.02684181
         tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
tmle.est   0.41944605  0.41944626   0.42606583 0.42901451   0.42901452  0.43205890   0.43613817 0.43613833   0.43613858
tmle.se    0.02719293  0.02719293   0.02720898 0.02725432   0.02725432  0.02720809   0.02733585 0.02733585   0.02733585
         tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
tmle.est  0.43964619   0.44271250 0.44271250   0.44612112  0.44612112
tmle.se   0.02743619   0.02738173 0.02738173   0.02731079  0.02731079

$Lev$convergenced.at.step
[1] 11

$Lev$messages
$Lev$messages[[1]]
[1] "Sigma was regularized"


$Lev$q.max.95
     95% 
2.602671 


$`Lev+5FU`
$`Lev+5FU`$init
          tau=36.525   tau=73.05 tau=109.575  tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
init.est 0.001729145 0.004325087 0.006057402 0.01476067  0.02001412 0.02706099  0.03413596 0.04568483  0.05638998
init.se  0.004662601 0.007165521 0.007748365 0.01095240  0.01090591 0.01086138  0.01150732 0.01398792  0.01577009
         tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
init.est 0.06625443  0.07527091 0.09077120  0.10271953 0.11200244  0.11668424 0.12894824  0.14322096  0.1508563
init.se  0.01657955  0.01710641 0.01756578  0.01859439 0.01910493  0.01927577 0.02013422  0.02119098  0.0217270
         tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
init.est  0.16812657 0.18165640  0.19524495 0.20109692  0.20794466 0.21679584  0.22863572 0.23958232  0.25260579
init.se   0.02255483 0.02284632  0.02312695 0.02332604  0.02360697 0.02386708  0.02446988 0.02457589  0.02497089
         tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
init.est  0.2576154   0.26465314  0.26868020   0.27473520 0.28687772   0.29501056  0.30314131   0.31031764  0.3195809
init.se   0.0252610   0.02528099  0.02529587   0.02532295 0.02582276   0.02616174  0.02626865   0.02655883  0.0269448
         tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
init.est   0.32164326  0.32576107   0.32987254 0.33605310    0.3381170  0.34225440   0.34536532 0.34640094    0.3484747
init.se    0.02695369  0.02722709   0.02745484 0.02756742    0.0276311  0.02777374   0.02785631 0.02785418    0.0279598
         tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
init.est  0.35366078   0.35573813 0.35887397   0.36412636  0.36834746
init.se   0.02795839   0.02796207 0.02797365   0.02800748  0.02813599

$`Lev+5FU`$km
        tau=36.525   tau=73.05 tau=109.575  tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
km.est 0.006920415 0.013840830 0.017301038 0.03114187  0.03114187 0.03114187  0.03460208 0.05536332  0.07266436
km.se  0.004876511 0.006872356 0.007670036 0.01021771  0.01021771 0.01021771  0.01075116 0.01345224  0.01526969
       tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
km.est 0.08304498   0.0899654 0.09688581  0.11072664 0.12110727  0.12456747 0.13840830  0.15916955 0.16608997
km.se  0.01623236   0.0168313 0.01740013  0.01845843 0.01919129  0.01942517 0.02031341  0.02151965 0.02189185
       tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
km.est  0.18339100 0.19031142   0.1972318 0.20415225  0.21107266 0.21799308  0.23529412 0.23875433  0.24567474
km.se   0.02276393 0.02309099   0.0234064 0.02371063  0.02400411 0.02428722  0.02495191 0.02507778  0.02532274
       tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
km.est 0.25259516   0.25259516  0.25259516   0.25259516 0.26297578    0.2698962   0.2733564   0.28373702 0.29415141
km.se  0.02555886   0.02555886  0.02555886   0.02555886 0.02589702    0.0261121   0.0262166   0.02651828 0.02680572
       tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
km.est   0.29415141  0.30110558   0.30807722 0.31506634   0.31857882  0.32560378    0.3291163 0.33262875    0.3396537
km.se    0.02680572  0.02698888   0.02716616 0.02733759   0.02742212  0.02758566    0.0276647 0.02774195    0.0278911
       tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
km.est  0.34667867   0.34667867 0.35019115   0.35721611  0.36426047
km.se   0.02803325   0.02803325 0.02810172   0.02823354  0.02836012

$`Lev+5FU`$tmle
          tau=36.525   tau=73.05 tau=109.575  tau=146.1 tau=182.625 tau=219.15 tau=255.675  tau=292.2 tau=328.725
tmle.est 0.005560547 0.012141473 0.015000745 0.02983542  0.02983613 0.02983622  0.03420038 0.05357023  0.07022881
tmle.se  0.004655463 0.007142399 0.007724943 0.01084121  0.01084121 0.01084121  0.01150089 0.01395101  0.01571608
         tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
tmle.est 0.07996795  0.08711618 0.09512623  0.10923765 0.11858887  0.12195007 0.13571912  0.15562999 0.16376384
tmle.se  0.01656014  0.01709075 0.01751112  0.01853626 0.01905667  0.01923552 0.02009694  0.02114173 0.02168653
         tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
tmle.est  0.18116025 0.18888883  0.19647246 0.20313052  0.20957095 0.21636561   0.2319773 0.23508990  0.24316256
tmle.se   0.02253016 0.02283579  0.02312554 0.02331764  0.02360714 0.02387318   0.0244943 0.02459579  0.02498203
         tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
tmle.est 0.24977890    0.2497843  0.24978723   0.24979202 0.26199905   0.26985256  0.27359383   0.28452830 0.29585403
tmle.se  0.02528329    0.0252833  0.02528331   0.02528331 0.02579036   0.02613088  0.02621295   0.02653412 0.02693708
         tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
tmle.est   0.29585601  0.30287549   0.30952778 0.31550196   0.31924079   0.3259899   0.32914606 0.33236189   0.33792882
tmle.se    0.02693708  0.02722872   0.02747059 0.02758175   0.02765469   0.0278103   0.02789353 0.02789837   0.02802246
         tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
tmle.est  0.34521189   0.34521396 0.34840190   0.35518443  0.36291366
tmle.se   0.02800958   0.02800958 0.02802118   0.02805833  0.02818493

$`Lev+5FU`$convergenced.at.step
[1] 57

$`Lev+5FU`$messages
$`Lev+5FU`$messages[[1]]
[1] "Sigma was regularized"


$`Lev+5FU`$q.max.95
     95% 
2.547183 


$Obs
$Obs$init
           tau=36.525    tau=73.05  tau=109.575   tau=146.1 tau=182.625  tau=219.15 tau=255.675  tau=292.2 tau=328.725
init.est 0.0025459356 0.0063630200 0.0089068200 0.021645872 0.029302193 0.039533023  0.04975950 0.06635576  0.08163232
init.se  0.0001555532 0.0003886119 0.0005438217 0.005391529 0.006866511 0.009162643  0.01099979 0.01288082  0.01407554
         tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
init.est 0.09561799  0.10832507 0.12999978   0.1465611 0.15934016  0.16575611 0.18247035  0.20175416 0.21199620
init.se  0.01484047  0.01595405 0.01789134   0.0189533 0.01949646  0.01969303 0.02016127  0.02095419 0.02110834
         tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
init.est  0.23497218 0.25278814  0.27051915 0.27810507  0.28694361 0.29830707  0.31340014 0.32724529  0.34358073
init.se   0.02202588 0.02272439  0.02339816 0.02369562  0.02390635 0.02423185  0.02441296 0.02466931  0.02511221
         tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
init.est 0.34982486   0.35855991  0.36353875   0.37099819 0.38586082   0.39574373  0.40556652   0.41418847 0.42525149
init.se  0.02512723   0.02536899  0.02558631   0.02565934 0.02607267   0.02628555  0.02646024   0.02645427 0.02662593
         tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
init.est   0.42770442  0.43259094   0.43745523 0.44473980   0.44716492  0.45201546   0.45565273 0.45686171   0.45927980
init.se    0.02671092  0.02684181   0.02684879 0.02687773   0.02689712  0.02690531   0.02697275 0.02697486   0.02697966
         tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
init.est  0.46531064    0.4677198 0.47134944    0.4774098  0.48226275
init.se   0.02701693    0.0270489 0.02704475    0.0271210  0.02720205

$Obs$km
       tau=36.525 tau=73.05 tau=109.575   tau=146.1 tau=182.625  tau=219.15 tau=255.675  tau=292.2 tau=328.725
km.est          0         0           0 0.009836066 0.016393443 0.029508197  0.04262295 0.05901639  0.06885246
km.se           0         0           0 0.005650857 0.007271029 0.009689857  0.01156680 0.01349359  0.01449837
       tau=365.25 tau=401.775 tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925 tau=657.45
km.est 0.07540984  0.09180328 0.1213115  0.14105728  0.1542212  0.15751213 0.17067600  0.19042181 0.19371278
km.se  0.01511954  0.01653367 0.0186947  0.01993698  0.0206894  0.02086899 0.02155589  0.02249953 0.02264747
       tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65 tau=986.175
km.est  0.22004052 0.23649536  0.25295021  0.2628231  0.27269602 0.28585989  0.29573279 0.31218763  0.32864248
km.se   0.02374391 0.02435665  0.02491859  0.0252328  0.02553058 0.02590303  0.02616458 0.02656795  0.02693221
       tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375 tau=1314.9
km.est 0.33193344   0.33851538  0.34838829    0.3516793 0.37142506    0.3812980  0.39446184   0.40433475 0.42078959
km.se  0.02700051   0.02713265  0.02731988    0.0273794 0.02770681    0.0278518  0.02802614   0.02814289 0.02831121
       tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1 tau=1643.625
km.est   0.42408056  0.43066249   0.43066249 0.44053540   0.44382636  0.44711733   0.45040830 0.45040830   0.45040830
km.se    0.02834098  0.02839666   0.02839666 0.02847059   0.02849268  0.02851351   0.02853308 0.02853308   0.02853308
       tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
km.est  0.45699024    0.4602812  0.4668631   0.47344508  0.48006894
km.se   0.02856842    0.0285842  0.0286120   0.02863479  0.02865511

$Obs$tmle
           tau=36.525         tau=73.05       tau=109.575   tau=146.1 tau=182.625  tau=219.15 tau=255.675  tau=292.2
tmle.est 4.325869e-17 0.000000052731927 0.000000052731927 0.009277532 0.015342573 0.028256252  0.04108313 0.05712068
tmle.se  1.854296e-17 0.000000007110751 0.000000007110751 0.005365310 0.006835563 0.009150925  0.01098758 0.01286433
         tau=328.725 tau=365.25 tau=401.775  tau=438.3 tau=474.825 tau=511.35 tau=547.875  tau=584.4 tau=620.925
tmle.est  0.06750832 0.07437688  0.09004877 0.11869014  0.13765030 0.14981936  0.15306897 0.16521334  0.18375697
tmle.se   0.01405627 0.01480801  0.01592204 0.01786343  0.01891757 0.01944617  0.01964458 0.02009189  0.02087272
         tau=657.45 tau=693.975  tau=730.5 tau=767.025 tau=803.55 tau=840.075  tau=876.6 tau=913.125 tau=949.65
tmle.est 0.18683638   0.2112492 0.22722139  0.24380895 0.25349153  0.26406683 0.27691000  0.28596508 0.30102881
tmle.se  0.02101528   0.0219265 0.02262356  0.02330274 0.02360804  0.02380884 0.02413492  0.02428261 0.02452514
         tau=986.175 tau=1022.7 tau=1059.225 tau=1095.75 tau=1132.275 tau=1168.8 tau=1205.325 tau=1241.85 tau=1278.375
tmle.est  0.31717671 0.32002197   0.32714921  0.33756799   0.34072288 0.36164705   0.37235853   0.3862344   0.39507091
tmle.se   0.02497758 0.02496971   0.02522101  0.02546918   0.02552781 0.02597911   0.02620895   0.0263961   0.02637016
         tau=1314.9 tau=1351.425 tau=1387.95 tau=1424.475   tau=1461 tau=1497.525 tau=1534.05 tau=1570.575 tau=1607.1
tmle.est 0.41207863   0.41588478  0.42258059   0.42258060 0.43270537   0.43603194  0.43930814    0.4428032  0.4428032
tmle.se  0.02655603   0.02665288  0.02679899   0.02679899 0.02682414   0.02684558  0.02684836    0.0269228  0.0269228
         tau=1643.625 tau=1680.15 tau=1716.675 tau=1753.2 tau=1789.725 tau=1826.25
tmle.est    0.4428032  0.44969903   0.45308630 0.45893004   0.46607007  0.47295520
tmle.se     0.0269228  0.02696318   0.02700087 0.02699532   0.02708254  0.02717482

$Obs$convergenced.at.step
[1] 9

$Obs$messages
$Obs$messages[[1]]
[1] "Sigma was regularized"


$Obs$q.max.95
     95% 
2.613997
#+end_example


Above we used the one-step TMLE to ensure compatible estimation. Here
we instead use the iterative TMLE which targets the survival
probabilities for each time-point separately. We also output the
estimating equations estimates which, like the iterative TMLE
estimates, solve each efficient influence curve equation
separately. Again, this is thus not guaranteed to yield compatible
estimation of the full survival curve: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.colon.surv.iterative.50 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            iterative=TRUE,
            output.km=TRUE, output.ee=TRUE, 
            tau=(1:50)/(5*2)*365.25)}) 
names(fit.colon.surv.iterative.50) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.iterative.50,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.50", "-iterative", ".rds"))
#+END_SRC    

We can check monotonicity of the curve estimated with the iterative
TMLE as follows, with the rows in the output below are the time-points
where the survival curve was increasing from one time-point to the
next (the amount that it is increasing is not large for these data,
but this should still illustrate the issue):

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$tmle) 
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,tmle.est)), by=which]
check.monotone[diff<0] 
#+END_SRC    

#+begin_example
 
            tmle.est            tmle.se which     time                diff
 1: 0.429853761293166 0.0274042876813724   Lev 1497.525 -0.0000289712240461
 2: 0.436917112674670 0.0274775035815274   Lev 1607.100 -0.0000173033928114
 3: 0.436874701782329 0.0274761623954313   Lev 1643.625 -0.0000424108923415
 4: 0.443300907572835 0.0275189259777731   Lev 1753.200 -0.0000897707783220
 5: 0.446409107974176 0.0274631029206613   Lev 1826.250 -0.0001964259722576
 6: 0.000000006871145 0.0000000007378397   Obs   73.050 -0.0000000008573657
 7: 0.000000005766241 0.0000000006434194   Obs  109.575 -0.0000000011049042
 8: 0.421308326187093 0.0268258321643754   Obs 1424.475 -0.0001410404809641
 9: 0.441525350772389 0.0269548108142467   Obs 1607.100 -0.0000422683431834
10: 0.441432896377600 0.0269536562228939   Obs 1643.625 -0.0000924543947891
#+end_example

The same way we can check monotonicity of the curve estimated by
solving the estimating equations as follows:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$ee) 
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,ee.est)), by=which]
check.monotone[diff<0]  
#+END_SRC    

#+begin_example
 
      ee.est      ee.se   which     time             diff
 1: 0.4203540 0.02734683     Lev 1387.950 -0.0000168700225
 2: 0.4298671 0.02740596     Lev 1497.525 -0.0000171453550
 3: 0.4369452 0.02748160     Lev 1607.100 -0.0000060395264
 4: 0.4369331 0.02748317     Lev 1643.625 -0.0000121358970
 5: 0.4434427 0.02753867     Lev 1753.200 -0.0000186171679
 6: 0.4467549 0.02750610     Lev 1826.250 -0.0000461483690
 7: 0.2517751 0.02528099 Lev+5FU 1059.225 -0.0000057658421
 8: 0.2517717 0.02529587 Lev+5FU 1095.750 -0.0000034836950
 9: 0.2517661 0.02532295 Lev+5FU 1132.275 -0.0000055024833
10: 0.2978114 0.02695369 Lev+5FU 1351.425 -0.0000001621608
11: 0.3500704 0.02796207 Lev+5FU 1716.675 -0.0000025898928
#+end_example

If we check the one-step TMLE, we just see that it is --- as expected
--- monotone:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]]
    out.jj <- t(fit.jj$tmle) 
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,tmle.est)), by=which]
check.monotone[diff<0]  
#+END_SRC    

: Empty data.table (0 rows and 5 cols): tmle.est,tmle.se,which,time,diff


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-one-step.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]]
    out.jj <- t(fit.jj$tmle)
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=1-tmle.est]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se] 
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) +  
    theme_bw(base_size=25) +     
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    xlab("time (years)") +  
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-survival-one-step.pdf" :exports none  :session *R* :width 12 :height 4 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]] 
    out.jj <- t(fit.jj$tmle)
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj],
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=-tmle.est]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="time")

pdat[, q.95:=q.95.y] 
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]
pdat[, which:=which.x]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +      
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    geom_hline(aes(yintercept=0), alpha=0.6, linetype="dotted") +  
    xlab("time (years)") +  
    ggtitle("Average treatment effects")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-estimating-equation.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$ee)
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, ee.est:=1-ee.est]
pdat[, q.95:=1.96]
pdat[, ci.lwr:=ee.est-q.95*ee.se] 
pdat[, ci.upr:=ee.est+q.95*ee.se]

pdat[, time:=time/365.25]

pdat[, diff:=diff(c(0,ee.est)), by=which]
pdat[, monotone:=diff<=0]

pdat[which=="Lev+5FU", which:="Lev+fluo"]
#pdat[diff>0]

ggplot(pdat) + #[which=="Lev+5FU"]) +  
    #xlim(2.8, 3.2) + ylim(0.748, 0.7485) + 
    theme_bw(base_size=25) +     
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    #geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
    #            col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=ee.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=ee.est, shape=monotone, size=1-monotone)) + 
    guides(size=FALSE, shape=FALSE) + 
    scale_shape_manual("", values=c(8, 16)) +
    xlab("time (years)") +  
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

** Analysis of the =colon= competing risks data


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))

cox.hal.sl.F1.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
cox.hal.sl.F2.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
cox.hal.sl.cens.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox.hal.sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
#+END_SRC


#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cause1.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve-0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-4]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
tune.grid[, extent.pos.y:=mean(cve), by=c("extent", "nodes", "which")]
tune.grid[nodes==1, extent.pos.x:=min(xnum)-1.5, by=c("nodes", "which")]
tune.grid[nodes==0, extent.pos.x:=min(xnum)+3, by=c("nodes", "which")]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox" & extent==0],
               aes(x=xnum, y=cve, col=differ## , shape=extent.label
                   ), shape=9, size=3) +
    geom_point(data=tune.grid[which=="cox" & extent==1],
               aes(x=xnum, y=cve, col=differ## , shape=extent.label
                   ), shape=8, size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)## , 
                       ## labels=expression("cut.two.way=0", "cut.two.way=10", "cut.two.way=15",
                       ##                   "cut.two.way=5", L[7]~"excluded", L[7]~"included")
                       ) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text), parse=TRUE) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2), parse=TRUE) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("cross-validated error") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+8, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+8), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[which=="cox" & nodes==1],
               aes(x=extent.pos.x, y=extent.pos.y, label=extent.label), parse=TRUE) +
    geom_label(data=tune.grid[which=="cox" & nodes==0],
               aes(x=extent.pos.x-1, y=extent.pos.y, label=extent.label), hjust=0, parse=TRUE) +
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.145,.475),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cause2.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.F2.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve+0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-3.75]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+6, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+6), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    ylim(110, tune.grid[, max(max.cve)]+6) + 
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cens.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.cens.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1] 
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve-0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-6]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+6.5, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+6.5), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    ylim(1120, tune.grid[, max(max.cve)]+6.5) + 
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation2.pdf" :exports none  :session *R* :width 16 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")          

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=which] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & differ, min.cve:=min.cve-4]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent), size=3) +
    scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
                                                    "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve), size=3) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+3, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    theme(axis.title.x=element_text(size=16, hjust=0.3),
          axis.text=element_text(size=12),
          legend.position=c(.875,.535),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation.pdf" :exports none  :session *R* :width 16 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")          

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)  

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", perfor:=unlist(lapply(sl.models, function(x) "perfor"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", perfor:=0]
tune.grid[which=="cox", rx.perfor:=unlist(lapply(sl.models, function(x) "rx*perfor"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", rx.perfor:=0]
tune.grid[which!="cox", table(rx.perfor, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, perfor)
tune.grid[, xnum:=as.numeric(1:.N), by=which] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & perfor, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & perfor, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "perfor")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & perfor, lab.text2:=paste0("perfor \n included")]
tune.grid[which=="cox" & !perfor, lab.text2:=paste0("perfor \n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "perfor")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "perfor")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & perfor, min.cve:=min.cve-4]
tune.grid[!nodes & !perfor, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=perfor, shape=rx.perfor), size=3) +
    scale_shape_manual("", values=c(1, 2), labels=c("rx*perfor excluded",
                                                    "rx*perfor included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve), size=3) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+3, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    theme(axis.title.x=element_text(size=16, hjust=0.3),
          axis.text=element_text(size=12),
          legend.position=c(.875,.535),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    


*** Target parameters evaluated at fixed time-point

We here compute TMLE estimates of all state occupation probabilities
evaluated after 3 years of follow-up, using for initial estimation of
both cause-specific hazards the super learner of Cox and HAL
estimators and for the censoring hazard the Cox super learner:


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.contmle.F1.F2.3yrs <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            output.km=TRUE, 
            simultaneous.ci=TRUE,
            target=1:2, 
            tau=3*365.25)}) 
names(fit.contmle.F1.F2.3yrs) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.F2.3yrs,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.F2.3yrs", ".rds"))
#+END_SRC    



#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.contmle.F1.F2.5 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE,
            output.km=TRUE, 
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            target=1:2, 
            tau=(1:5)*365.25)}) 
names(fit.contmle.F1.F2.5) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.F2.5,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.F2.5", ".rds"))
#+END_SRC    


The output from the function call gives the estimates of the absolute
risks and the event-free survival probability:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.contmle.F1.F2.3yrs 
#+END_SRC    

#+begin_example
$Lev
$Lev$init
$Lev$init$F1
         tau=1095.75
init.est  0.48926006
init.se   0.02836712

$Lev$init$F2
         tau=1095.75
init.est 0.015357277
init.se  0.007613289

$Lev$init$S
         tau=1095.75
init.est  0.49538266
init.se   0.02843236


$Lev$km
$Lev$km$F1
       tau=1095.75
km.est  0.47619048
km.se   0.02912751

$Lev$km$F2
       tau=1095.75
km.est 0.020408163
km.se  0.008246143


$Lev$tmle
$Lev$tmle$F1
         tau=1095.75
tmle.est  0.47748809
tmle.se   0.02835463

$Lev$tmle$F2
         tau=1095.75
tmle.est 0.017613508
tmle.se  0.007595705

$Lev$tmle$S
         tau=1095.75
tmle.est  0.50489840
tmle.se   0.02843068


$Lev$convergenced.at.step
[1] 14

$Lev$q.max.95
    95% 
1.96621 


$`Lev+5FU`
$`Lev+5FU`$init
$`Lev+5FU`$init$F1
         tau=1095.75
init.est  0.33816943
init.se   0.02751093

$`Lev+5FU`$init$F2
         tau=1095.75
init.est 0.025097429
init.se  0.008617509

$`Lev+5FU`$init$S
         tau=1095.75
init.est  0.63673314
init.se   0.02796726


$`Lev+5FU`$km
$`Lev+5FU`$km$F1
       tau=1095.75
km.est  0.33564014
km.se   0.02777728

$`Lev+5FU`$km$F2
       tau=1095.75
km.est 0.024221453
km.se  0.009043297


$`Lev+5FU`$tmle
$`Lev+5FU`$tmle$F1
         tau=1095.75
tmle.est   0.3352188
tmle.se    0.0275060

$`Lev+5FU`$tmle$F2
         tau=1095.75
tmle.est 0.023659105
tmle.se  0.008619622

$`Lev+5FU`$tmle$S
         tau=1095.75
tmle.est  0.64112211
tmle.se   0.02796174


$`Lev+5FU`$convergenced.at.step
[1] 8

$`Lev+5FU`$q.max.95
     95% 
1.964605 


$Obs
$Obs$init
$Obs$init$F1
         tau=1095.75
init.est  0.49721013
init.se   0.02758601

$Obs$init$F2
         tau=1095.75
init.est  0.02406588
init.se   0.00713911

$Obs$init$S
         tau=1095.75
init.est  0.47872399
init.se   0.02757703


$Obs$km
$Obs$km$F1
       tau=1095.75
km.est  0.48932819
km.se   0.02865829

$Obs$km$F2
       tau=1095.75
km.est 0.019752491
km.se  0.007983817


$Obs$tmle
$Obs$tmle$F1
         tau=1095.75
tmle.est  0.48104591
tmle.se   0.02755615

$Obs$tmle$F2
         tau=1095.75
tmle.est 0.020286726
tmle.se  0.007138789

$Obs$tmle$S
         tau=1095.75
tmle.est  0.49866736
tmle.se   0.02752291


$Obs$convergenced.at.step
[1] 12

$Obs$q.max.95
     95% 
1.967607
#+end_example


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-competing-risks-fixed.pdf" :exports none  :session *R* :width 12 :height 3.3 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")       

pdat <- data.table(do.call("rbind", lapply(1:length(fit.contmle.F1.F2.3yrs), function(jj) {
    fit.jj <- fit.contmle.F1.F2.3yrs[[jj]]
    out.jj <- do.call("cbind", fit.jj$tmle)
    colnames(out.jj) <- names(fit.jj$tmle) 
    return(data.table(t(out.jj), parameter=colnames(out.jj),
                      q.95=fit.jj$q.max.95, which=names(fit.contmle.F1.F2.3yrs)[jj])) 
})))

pdat[parameter=="F1", parameter:="F[1]"] 
pdat[parameter=="F2", parameter:="F[2]"]

pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]
pdat[, no:=as.numeric(factor(which, levels=unique(which)))]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          axis.text.x=element_text(size=12),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,3.5),  
                       labels=unique(pdat$which)) +   
    facet_grid(. ~ parameter, scales="free", labeller=label_parsed) + 
    xlab("TMLE estimate") +  
    ggtitle("Treatment-specific absolute risk probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-competing-risks-fixed.pdf" :exports none  :session *R* :width 12 :height 3.0 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")     

pdat <- data.table(do.call("rbind", lapply(1:length(fit.contmle.F1.F2.3yrs), function(jj) {
    fit.jj <- fit.contmle.F1.F2.3yrs[[jj]] 
    out.jj <- do.call("cbind", fit.jj$tmle)
    colnames(out.jj) <- names(fit.jj$tmle)
    return(data.table(t(out.jj), parameter=colnames(out.jj), 
                      q.95=fit.jj$q.max.95, which=names(fit.contmle.F1.F2.3yrs)[jj])) 
})))

pdat[parameter=="F1", parameter:="F[1]"]
pdat[parameter=="F2", parameter:="F[2]"]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="parameter")

pdat[, q.95:=q.95.y] 
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, which:=which.x]
pdat[, no:=as.numeric(factor(which, levels=unique(which)))]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          axis.text.x=element_text(size=12),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(),  
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_vline(aes(xintercept=0), alpha=0.6, linetype="dotted") +  
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,2.5), 
                       labels=unique(pdat$which)) + 
    facet_grid(. ~ parameter, scales="free", labeller=label_parsed) + 
    xlab("TMLE estimate") + 
    ggtitle("Average treatment effects") 
#+END_SRC    



[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Target parameters evaluated at multiple time-points 


We here compute TMLE estimates of the absolute risk of cancer relapse
evaluated at a grid of 10 equidistant follow-up time-points, using
again for initial estimation of both cause-specific hazards the super
learner of Cox and HAL estimators and for the censoring hazard the Cox
super learner:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.contmle.F1.10 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE,
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            output.km=TRUE, 
            target=1, 
            tau=(1:10)/2*365.25)}) 
names(fit.contmle.F1.10) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.10,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.10", ".rds"))
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.contmle.F1.20 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, verbose=TRUE, 
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            output.km=TRUE, 
            target=1, 
            tau=(1:20)/(2*2)*365.25)}) 
names(fit.contmle.F1.20) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.20,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.20", ".rds"))
#+END_SRC    


Look at the output from the function call: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.contmle.F1.10 
#+END_SRC    

#+begin_example
$Lev
$Lev$init
$Lev$init$F1
         tau=182.625 tau=365.25 tau=547.875 tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.11705005 0.26554460  0.36492812 0.4312046  0.45959382  0.48893685   0.50705137 0.51669773    0.5299512
init.se   0.01975827 0.02549214  0.02697528 0.0276954  0.02792219  0.02885253   0.02888473 0.02889107    0.0288886
         tau=1826.25
init.est  0.54076073
init.se   0.02892605


$Lev$km
$Lev$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est   0.1224490 0.27210884  0.36054422 0.42517007  0.44897959  0.47619048   0.49319728 0.49659864   0.51712915
km.se    0.0191179 0.02595559  0.02800341 0.02883217  0.02900838  0.02912751   0.02915789 0.02915992   0.02915041
       tau=1826.25
km.est   0.5239808
km.se    0.0291366


$Lev$tmle
$Lev$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.12725638 0.27585843  0.36364620 0.42740990  0.45108529   0.4826794   0.49924792 0.50295133   0.52275511
tmle.se   0.01973582 0.02544605  0.02692778 0.02764068  0.02786207   0.0288811   0.02891968 0.02892993   0.02889269
         tau=1826.25
tmle.est  0.52973049
tmle.se   0.02893836


$Lev$convergenced.at.step
[1] 7

$Lev$q.max.95
     95% 
2.227746 


$`Lev+5FU`
$`Lev+5FU`$init
$`Lev+5FU`$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.07235724 0.17142955  0.24302683 0.29358590  0.31599994  0.33966356   0.35455057 0.36256342    0.3736777
init.se   0.01401494 0.02041008  0.02409508 0.02614062  0.02657322  0.02742148   0.02768576 0.02776814    0.0278182
         tau=1826.25
init.est  0.38283201
init.se   0.02801992


$`Lev+5FU`$km
$`Lev+5FU`$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.05882353 0.14878893  0.23183391 0.29065744  0.30795848  0.33564014   0.35294118 0.35642071   0.35993979
km.se   0.01384083 0.02093413  0.02482373 0.02670975  0.02715584  0.02777728   0.02811086 0.02817422   0.02823908
       tau=1826.25
km.est  0.37753519
km.se   0.02853805


$`Lev+5FU`$tmle
$`Lev+5FU`$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.06020404 0.14781306  0.22946650 0.28774592  0.30509063  0.33439284   0.35125776 0.35486827   0.35805632
tmle.se   0.01402144 0.02036381  0.02407069 0.02613298  0.02655417  0.02742577   0.02769232 0.02776829   0.02779808
         tau=1826.25
tmle.est  0.37612826
tmle.se   0.02802812


$`Lev+5FU`$convergenced.at.step
[1] 8

$`Lev+5FU`$q.max.95
     95% 
2.231745 


$Obs
$Obs$init
$Obs$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.11939485 0.27028219  0.37061788 0.43719314  0.46559030  0.49481104   0.51280343 0.52235991   0.53546751
init.se   0.01841578 0.02440189  0.02629321 0.02695274  0.02730011  0.02746709   0.02765023 0.02760199   0.02764509
         tau=1826.25
init.est  0.54613614
init.se   0.02766481


$Obs$km
$Obs$km$F1
       tau=182.625 tau=365.25 tau=547.875 tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.12786885 0.27868852  0.37071681 0.4267277  0.46297011  0.48932819   0.50580199 0.52557056   0.53874960
km.se   0.01912156 0.02567267  0.02766879 0.0283454  0.02858221  0.02865829   0.02866512 0.02863202   0.02858486
       tau=1826.25
km.est  0.54533912
km.se   0.02855372


$Obs$tmle
$Obs$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375  tau=1461 tau=1643.625
tmle.est  0.12597261 0.27146890  0.36053380 0.41683900  0.45346100  0.48047832    0.4976460 0.5175123   0.53059357
tmle.se   0.01840795 0.02439073  0.02626887 0.02690593  0.02727408  0.02744011    0.0276249 0.0275971   0.02764127
         tau=1826.25
tmle.est  0.53663074
tmle.se   0.02765335


$Obs$convergenced.at.step
[1] 5

$Obs$q.max.95
     95% 
2.238451
#+end_example

#+begin_example
$Lev
$Lev$init
$Lev$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est   0.1167954 0.26540994   0.3648577 0.43127963  0.45977603  0.48926006   0.50750214 0.51722828   0.53060030
init.se    0.0193665 0.02547524   0.0270024 0.02776233  0.02802278  0.02836688   0.02843318 0.02845304   0.02846771
         tau=1826.25
init.est   0.5415107
init.se    0.0285176


$Lev$km
$Lev$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est   0.1224490 0.27210884  0.36054422 0.42517007  0.44897959  0.47619048   0.49319728 0.49659864   0.51712915
km.se    0.0191179 0.02595559  0.02800341 0.02883217  0.02900838  0.02912751   0.02915789 0.02915992   0.02915041
       tau=1826.25
km.est   0.5239808
km.se    0.0291366


$Lev$tmle
$Lev$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.12552921 0.27628375  0.36203677 0.42573888  0.45118075  0.47734425   0.49316313 0.50103274    0.5165852
tmle.se   0.01934004 0.02541927  0.02697648 0.02773627  0.02800323  0.02834991   0.02841354 0.02842329    0.0284535
         tau=1826.25
tmle.est  0.52678316
tmle.se   0.02849799


$Lev$convergenced.at.step
[1] 101

$Lev$q.max.95
     95% 
2.222829 


$`Lev+5FU`
$`Lev+5FU`$init
$`Lev+5FU`$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.07217484 0.17091586  0.24205926 0.29230580  0.31460552  0.33816943   0.35302632 0.36103308   0.37214707
init.se   0.01402459 0.02049811  0.02421574 0.02622656  0.02668265  0.02751099   0.02775695 0.02783808   0.02788941
         tau=1826.25
init.est  0.38130539
init.se   0.02809854


$`Lev+5FU`$km
$`Lev+5FU`$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.05882353 0.14878893  0.23183391 0.29065744  0.30795848  0.33564014   0.35294118 0.35642071   0.35993979
km.se   0.01384083 0.02093413  0.02482373 0.02670975  0.02715584  0.02777728   0.02811086 0.02817422   0.02823908
       tau=1826.25
km.est  0.37753519
km.se   0.02853805


$`Lev+5FU`$tmle
$`Lev+5FU`$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.06029411 0.14809761   0.2297420 0.28738558  0.30585282   0.3344838   0.34996950 0.35467146   0.36090199
tmle.se   0.01403929 0.02046458   0.0242083 0.02622643  0.02667109   0.0275110   0.02775821 0.02783342   0.02786805
         tau=1826.25
tmle.est  0.37554211
tmle.se   0.02810211


$`Lev+5FU`$convergenced.at.step
[1] 200

$`Lev+5FU`$q.max.95
     95% 
2.226305 


$Obs
$Obs$init
$Obs$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.11999158 0.27176466  0.37247248 0.43930424  0.46783411   0.4972101   0.51533146 0.52496637    0.5381880
init.se   0.01843779 0.02438973  0.02636525 0.02707843  0.02740829   0.0275867   0.02776279 0.02771404    0.0277523
         tau=1826.25
init.est  0.54895145
init.se   0.02777321


$Obs$km
$Obs$km$F1
       tau=182.625 tau=365.25 tau=547.875 tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.12786885 0.27868852  0.37071681 0.4267277  0.46297011  0.48932819   0.50580199 0.52557056   0.53874960
km.se   0.01912156 0.02567267  0.02766879 0.0283454  0.02858221  0.02865829   0.02866512 0.02863202   0.02858486
       tau=1826.25
km.est  0.54533912
km.se   0.02855372


$Obs$tmle
$Obs$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.12491865 0.27026894   0.3596506 0.41818869  0.45121671  0.48037609   0.50003182 0.51422788   0.52856677
tmle.se   0.01843008 0.02437708   0.0263408 0.02703093  0.02738051  0.02755775   0.02773445 0.02770405   0.02774293
         tau=1826.25
tmle.est  0.53814667
tmle.se   0.02775702


$Obs$convergenced.at.step
[1] 85

$Obs$q.max.95
     95% 
2.238037
#+end_example

#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-competing-risks-F1-10.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")       

pdat <- do.call("rbind", lapply(1:length(fit.contmle.F1.10), function(jj) {
    fit.jj <- fit.contmle.F1.10[[jj]]
    out.jj <- t(fit.jj$tmle$F1)
    return(data.table(out.jj, which=names(fit.contmle.F1.10)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat <- merge(pdat, data.table(q.max.95=unlist(lapply(fit.contmle.F1.10, function(x) x$q.max.95)), 
                               which=names(fit.contmle.F1.10)), by="which")

pdat[, tmle.est:=tmle.est]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se] 
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(#legend.position="bottom", 
        axis.title.y=element_text(angle=90, size=20), 
        axis.title.x=element_text(size=20),
        legend.key.size=unit(3,"line"), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    #geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    #scale_y_continuous("", unique(pdat$no),    
    #                   limits=c(0.5,3.5), 
    #                   labels=unique(pdat$which)) +   
    xlab("time (years)") +   
    ggtitle("Treatment-specific absolute risk of cancer relapse")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-competing-risks-F1-10.pdf" :exports none  :session *R* :width 12 :height 4 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    

pdat <- do.call("rbind", lapply(1:length(fit.contmle.F1.10), function(jj) {
    fit.jj <- fit.contmle.F1.10[[jj]]
    out.jj <- t(fit.jj$tmle$F1)
    return(data.table(out.jj, which=names(fit.contmle.F1.10)[jj], 
                      q.95=fit.jj$q.max.95, time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=tmle.est]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="time")
pdat[, q.95:=q.95.y]  
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, which:=which.x]

pdat <- merge(pdat, data.table(q.max.95=unlist(lapply(fit.contmle.F1.10, function(x) x$q.max.95)), 
                               which=names(fit.contmle.F1.10)), by="which")

pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +      
    theme(#legend.position="bottom", 
        axis.title.y=element_text(angle=90, size=20), 
        axis.title.x=element_text(size=20),
        legend.key.size=unit(3,"line"), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    #geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    geom_hline(aes(yintercept=0), alpha=0.6, linetype="dotted") +  
    xlab("time (years)") +  
    ggtitle("Average treatment effects")
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

* Dependencies :noexport:

** R-version

The code has been tested with the following R version

#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
version  
#+END_SRC

#+begin_example
               _                           
platform       x86_64-pc-linux-gnu         
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          4                           
minor          0.3                         
year           2020                        
month          10                          
day            10                          
svn rev        79318                       
language       R                           
version.string R version 4.0.3 (2020-10-10)
nickname       Bunny-Wunnies Freak Out
#+end_example

and the following package versions:

#+BEGIN_SRC R  :results output raw drawer  :exports results  :session *R* :cache yes  
pp <- c("data.table", "zoo", "glmnet", "stringr", "nleqslv", "prodlim", "ggplot2", "gridExtra", "survival", "riskRegression", "MASS", "hdnom")
Publish::org(data.table(Package=pp,Version=sapply(pp,function(x) as.character(packageVersion(x))))) 
#+END_SRC

#+RESULTS[<2021-10-26 13:12:32> 5277b86706f38c0f421795154abdeb26ccff69db]:
:RESULTS:
| Package        |    Version |
|----------------+------------|
| data.table     |     1.14.0 |
| zoo            |      1.8.9 |
| glmnet         |        4.1 |
| stringr        |      1.4.0 |
| nleqslv        |      3.3.2 |
| prodlim        | 2019.11.13 |
| ggplot2        |      3.3.5 |
| gridExtra      |        2.3 |
| survival       |      3.2.7 |
| riskRegression |  2021.6.30 |
| MASS           |     7.3.53 |
:END:
