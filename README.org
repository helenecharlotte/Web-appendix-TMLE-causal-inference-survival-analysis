# Web-appendix-TMLE-causal-inference-survival-analysis
* Web appendix 

This is the web-appendix to our manuscript entitled /Targeted/
/maximum likelihood estimation for causal inference in survival and
competing risks analysis/. \\

We provide =R= code to apply our current implementations of TMLE for
estimation of causal parameters in survival and competing risks
settings; this includes the iterative and the one-step targeting
procedures as well as super learning to combine different Cox
regression models or variations over the highly adaptive
lasso (HAL) estimator. \\

Although the current implementations can be applied to new data
settings, we emphasize that our implementations remain to be made into
a more user-friendly software package. Current and future work is
involved with this.

** Overview

We consider as an example the analysis of a particular dataset as well
as a simulated version resembling it. The point of looking at the
simulated version is that we know the truth, both in terms of the
underlying statistical model and the true values of the considered
target parameters.\\

We will go through the following:

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#data-example][Presentation of the data example]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#simulated-version-of-the-colon-data][Simulated version of the data example]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#true-values-of-target-parameters-box-1][Computing true values of target parameters]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#targeting-hazard-estimators-for-real-valued-parameter][Targeting hazard estimators for real-valued parameter]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#targeting-hazard-estimators-for-multivariate-parameter][Targeting hazard estimators for multivariate parameter]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#initial-estimation-for-analysis-of-the-colon-data][On the initial estimation for analysis of the colon data]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#analysis-of-the-colon-survival-data][Analysis of the colon survival data]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-fixed-time-point][Fixed time-point]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-multiple-time-points][Multiple time-points]]

- [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#analysis-of-the-colon-competing-risks-data][Analysis of the colon competing risks data]]

 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-fixed-time-point-1][Fixed time-point]]
 + [[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis#target-parameters-evaluated-at-multiple-time-points-1][Multiple time-points]]

*Note:* To run any of the code chunks below you need to load the
following =R= script:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports none  :session *R* :cache yes  
setwd("~/research/TMLE-from-2020june/survival-baseline/Web-appendix-TMLE-causal-inference-survival-analysis/")
#+END_SRC

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/load.R")  
#+END_SRC

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports none  :session *R* :cache yes  
path.to.file <- "~/research/TMLE-from-2020june/survival-baseline/Web-appendix-TMLE-causal-inference-survival-analysis"
#+END_SRC

** Data example 

In our manuscript we use the publicly available dataset =colon= from
the =survival= package in =R= for demonstration. These are data
from a trial on adjuvant chemotherapy for colon cancer, comparing
levamisole treatment against levamisole treatment combined with
fluorouracil (a chemotherapy agent) against no treatment. 

The raw data available in R consist of two rows per subject:
one for cancer recurrence and one for death. This allows us to work
with the data in two different forms, for two different purposes, as
follows:

- Survival outcome data: :: We consider treatment effect estimation in
     the setting where the event of interest is all-cause mortality
     and there are no competing causes.
- Competing risks data: :: We consider treatment effect estimation in
     the setting with two competing causes being cancer recurrence and
     death.

In this script we load the =colon= data and create the two datasets
above:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/preprocess.colon.data.R")     
#+END_SRC    

Number of subjects assigned to each treatment (=rx=) option:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
colon.surv[, table(rx)] 
#+END_SRC 

: rx
:     Obs     Lev Lev+5FU 
:     305     294     289

Number of events in the survival data (=colon.surv=): 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
out <- cbind(colon.surv[, .N, by="event"],   
             colon.surv[, max(time), by="event"][, max.follow.up:=V1][, -c("event", "V1"), with=FALSE])
colnames(out) <- c("event", "N", "max follow-up")
out    
#+END_SRC    

:    event   N max follow-up
: 1:     1 430          2910
: 2:     0 458          3329

Number of events in the competing risks data (=colon.cr=):

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
out <- cbind(colon.cr[order(event)][, .N, by="event"],   
             colon.cr[order(event)][, max(time), by="event"][, max.follow.up:=V1][, -c("event", "V1"), with=FALSE]) 
colnames(out) <- c("event", "N", "max follow-up")
out 
#+END_SRC    

:  
:   event   N max follow-up
: 1:     0 405          3329
: 2:     1 446          2695
: 3:     2  37          2789

Note that for both datasets we simply removed observations with
missing covariates.\\


#+Begin_Src latex :file "~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/figures/graph-multistate-colon.pdf" :packages '(("" "tikz")) :border 1em :results raw :exports none
  % Define block styles   
  \usetikzlibrary{shapes,arrows,snakes} 
  \tikzstyle{astate} = [circle, draw, text centered, font=\footnotesize]
  \tikzstyle{bstate} = [text centered, font=\footnotesize]
  \tikzstyle{cstate} = [text centered, font=\footnotesize,fill=gray!20, draw=none, rectangle, rounded corners]
  \tikzstyle{rstate} = [circle, draw, text centered, font=\footnotesize, minimum size=1.3cm]
  \tikzstyle{r2state} = [circle, draw, text centered, font=\footnotesize, minimum size=1.8cm]
  \tikzstyle{r1state} = [regular polygon,regular polygon sides=9, fill=gray!20, draw, text centered, font=\footnotesize, minimum size=0.05cm]
  \tikzstyle{r3state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, font=\footnotesize]
  \tikzstyle{r3stategray} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, font=\footnotesize, color=gray] 
  \tikzstyle{r4state} = [draw,ellipse,ellipse left angle=70,trapezium right angle=-70,fill=white!20,minimum height=0.6cm, font=\footnotesize]
  \tikzstyle{r33state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70,minimum height=0.7cm, font=\footnotesize]
  \tikzstyle{r333state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70,minimum height=0.3cm, font=\footnotesize]
  \tikzstyle{r3333state} = [draw,rectangle,rectangle left angle=70,trapezium right angle=-70, rounded corners, minimum height=0.5cm, font=\footnotesize]
  \tikzstyle{r5state} = [draw, star, star points=10, ]

  \begin{tikzpicture}[->,>=stealth', shorten >=1pt, auto, node distance=2.8cm, semithick, font=\sffamily]
   \node [r3state] (0) at (-0.5,0.2) {};
    \node [bstate, left] (0a) at (-0.7,0.2) {\scriptsize initial state};
    \node [r3state] (00) at (1.0,0.5) {1};
 %   \node [r3state] (1) at (1.0,0.2) {1}; 
    \node [bstate, right] (1a) at (1.2, 0.5) {\scriptsize cancer relapse};
    \node [r3state] (3) at (1.0,-0.1) {2}; 
    \node [bstate, right] (3a) at (1.2, -0.1) {\scriptsize relapse-free death}; 
    \path (0) edge node {} (00) 
      %    (0) edge node {} (1)
        %  (0) edge node {} (2)  
          (0) edge node {} (3)  
          (0c) edge [dashed, white] node {} (a0) 
  \end{tikzpicture} 
#+end_src




[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]



** Simulated version of the =colon= data

The following script sets up simple functionality to create simulated
versions of the =colon= data:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results none :exports code  :session *R* :cache yes  
source("./usage/synthesize.colon.data.R")       
#+END_SRC    

To create a simulated version of the survival data, we run code as
follows:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
#-- fit models to data;   
fit.colon <- fit.colon.fun(
    formula.1=Surv(time, event==1)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.0=Surv(time, event==0)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.treat=rx~sex+age+nodes+differ+obstruct+perfor+adhere+extent+surg,
    d=colon.surv)   
#-- here we simulate data (fixed seed);  
set.seed(15)   
(sim.colon.surv <- synthesize.colon.fun(fit.colon=fit.colon, d=colon.surv, name.treat="rx", event.name="event")) 
#+END_SRC   

#+begin_example
     sex age obstruct perfor adhere nodes differ extent surg rx.num      rx      time event
  1:   0  69        0      0      0    12      2      3    0      3 Lev+5FU  634.0321     1
  2:   0  48        0      0      0     1      2      3    0      2     Lev  889.8198     1
  3:   0  42        0      0      0     6      1      3    0      2     Lev  670.7178     1
  4:   0  78        0      0      0     3      2      3    0      3 Lev+5FU 1922.5082     1
  5:   1  49        0      0      0    10      2      3    0      1     Obs 1830.0520     1
 ---                                                                                       
884:   0  75        0      0      0     2      3      3    0      2     Lev  860.8502     1
885:   0  76        0      0      0     1      2      3    0      1     Obs 1527.2115     1
886:   0  51        0      0      0     4      2      3    1      3 Lev+5FU 2665.0731     0
887:   0  63        0      0      0     5      2      3    1      3 Lev+5FU 2577.7704     0
888:   1  51        1      0      0     4      2      3    1      2     Lev 2932.9771     1
#+end_example

The hazards are generated from Weibull distributions with functional
form as specified by the =formula.1= (for the hazard of the event
distribution) and =formula.0= (for the hazard of the censoring
distribution) arguments; note that for both we simply include main
effects of treatment and all covariates. The treatment variable
(called =rx=) is generated from the model including, as well, all main
effects of covariates. The parameters for each model are estimated
based on the observed colon data with the function =fit.colon.fun= and
then used to generate the simulated data with
=synthesize.colon.fun=. \\


To create a simulated version of the competing risks data, we
similarly run code as follows:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
#-- fit models to data; 
fit.colon.cr <- fit.colon.fun(      
    formula.1=Surv(time, event==1)~rx+sex+differ+age+nodes.squared+obstruct+perfor+adhere+extent+surg+rx*sex+rx*perfor+rx*age,
    formula.2=Surv(time, event==2)~rx+sex+nodes+differ+age+obstruct+adhere+extent+surg,
    formula.0=Surv(time, event==0)~rx+sex+nodes+differ+age+obstruct+perfor+adhere+extent+surg,
    formula.treat=rx~sex+age+nodes+differ+obstruct+perfor+adhere+extent+surg,
    d=colon.cr)  
#-- here we simulate data (fixed seed); 
set.seed(31)      
(sim.colon.cr <- synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event"))
#+END_SRC   

#+begin_example
     sex age obstruct perfor adhere nodes differ extent surg nodes.squared rx.num      rx      time event
  1:   0  55        1      0      0     4      1      3    0            16      2     Lev 2590.1288     0
  2:   0  64        0      0      0     1      2      3    0             1      2     Lev  862.2267     1
  3:   1  63        0      0      0     2      3      3    0             4      1     Obs  244.6612     1
  4:   1  67        1      0      0     1      2      3    1             1      3 Lev+5FU 1446.1525     1
  5:   0  45        0      0      0     3      2      3    0             9      3 Lev+5FU 3224.6467     0
 ---                                                                                                     
884:   0  71        0      0      0    20      2      3    0           400      3 Lev+5FU 2117.5456     0
885:   0  34        1      0      0     3      1      3    0             9      1     Obs 2314.8256     0
886:   1  66        0      0      0     2      2      4    0             4      1     Obs  488.2843     0
887:   1  50        1      0      1     1      2      3    0             1      2     Lev  127.1821     1
888:   1  42        1      0      0     5      2      3    0            25      1     Obs  525.6158     1
#+end_example

Here the cause-specific hazards are generated from Weibull
distributions with functional forms as specified by the =formula.1=
and =formula.2= arguments. As before, =formula.0= specifies the hazard
of the censoring distribution.  Note that we specified the model for
the cause-1 specific hazard with a squared effect of =nodes= and
interactions between treatment and three of the covariates.

[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** True values of target parameters

To compute the approximations to the true values of the target
parameters for the simulated competing risks data, we run the
following code:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
true.a0 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=0, tau=tt*365.25)) 
true.a1 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=1, tau=tt*365.25))   
true.a2 <- lapply((1:10)/2, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                              n=1e6, get.true.value=2, tau=tt*365.25))
#+END_SRC   


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Absolute risks under treatment=Obs:")  
tab0 <- rbind(sapply(true.a0, function(x) x["F1"]), 
              sapply(true.a0, function(x) x["F2"])) 
rownames(tab0) <- c("F1", "F2") 
colnames(tab0) <- paste0((1:10)/2)
print(tab0)
message("")
message("Absolute risks under treatment=Lev:") 
tab1 <- rbind(sapply(true.a1, function(x) x["F1"]), 
              sapply(true.a1, function(x) x["F2"]))
rownames(tab1) <- c("F1", "F2") 
colnames(tab1) <- paste0((1:10)/2) 
print(tab1)
message("")
message("Absolute risks under treatment=Lev+5FU:") 
tab2 <- rbind(sapply(true.a2, function(x) x["F1"]), 
              sapply(true.a2, function(x) x["F2"]))
rownames(tab2) <- c("F1", "F2") 
colnames(tab2) <- paste0((1:10)/2)
print(tab2)
#+END_SRC    

#+begin_example
Absolute risks under treatment=Obs:
 
       0.5        1      1.5        2      2.5        3      3.5       4      4.5        5
F1 0.146465 0.227907 0.288342 0.339962 0.382316 0.419372 0.452278 0.48266 0.508024 0.532319
F2 0.000400 0.001145 0.002186 0.003464 0.004639 0.005960 0.007595 0.00901 0.010475 0.011990

Absolute risks under treatment=Lev:
 
       0.5        1      1.5        2      2.5        3      3.5        4      4.5        5
F1 0.137236 0.212368 0.271814 0.320762 0.361983 0.397857 0.430558 0.459212 0.486208 0.509233
F2 0.000235 0.000755 0.001475 0.002178 0.003173 0.004224 0.005209 0.006190 0.007314 0.008595

Absolute risks under treatment=Lev+5FU:
 
       0.5        1      1.5        2      2.5        3      3.5        4      4.5        5
F1 0.088497 0.139775 0.179475 0.214357 0.244999 0.272068 0.296521 0.318285 0.339306 0.357575
F2 0.000180 0.000538 0.001043 0.001834 0.002531 0.003325 0.004253 0.005287 0.006230 0.007313
#+end_example


We see for example that the average treatment effect of levamisole
    treatment compared to no treatment on the cause-one specific
    absolute risk beyond three years is:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Average treatment effect of levamisole compared to no treatment:") 
round(as.numeric(true.a1[(1:10)/2==3][[1]]["F1"] - true.a0[(1:10)/2==3][[1]]["F1"]),4) 
message("")
message("Average treatment effect of levamisole plus fluorouracil compared to no treatment:")  
round(as.numeric(true.a2[(1:10)/2==3][[1]]["F1"] - true.a0[(1:10)/2==3][[1]]["F1"]),4)
#+END_SRC   

: Average treatment effect of levamisole compared to no treatment:
: [1] -0.0215
: 
: Average treatment effect of levamisole plus fluorouracil compared to no treatment:
: [1] -0.1473


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
library(xtable)
tab0 <- rbind(sapply(true.a0, function(x) x["F1"]), 
              sapply(true.a0, function(x) x["F2"])) 
rownames(tab0) <- c("F1", "F2") 
colnames(tab0) <- paste0((1:10)/2)
print(xtable(tab0, align=rep("c", length(true.a0)+1), digits=3)) 

tab1 <- rbind(sapply(true.a1, function(x) x["F1"]), 
              sapply(true.a1, function(x) x["F2"]))
rownames(tab1) <- c("F1", "F2")  
colnames(tab1) <- paste0((1:10)/2) 
print(xtable(tab1, align=rep("c", length(true.a1)+1), digits=3)) 

tab2 <- rbind(sapply(true.a2, function(x) x["F1"]), 
              sapply(true.a2, function(x) x["F2"]))
rownames(tab2) <- c("F1", "F2") 
colnames(tab2) <- paste0((1:10)/2)
print(xtable(tab2, align=rep("c", length(true.a2)+1), digits=3)) 
#+END_SRC    

The approximations above were obtained by simulating a large dataset
(n = 1e6) from each counterfactual scenario (with no censoring and
setting A = 0,1,2 for all subjects) and computing the sample average
of the outcome indicator at the time-horizon of interest.


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Targeting hazard estimators for real-valued parameter

We here show the code to apply our TMLE function to the simulated data
to target the real-valued parameter being the absolute risk of cancer
relapse after 3 years of follow-up under treatment with levamisole
plus fluorouracil. \\

Note that we simply use a Cox regression including main effects of all
covariates for initial estimation of each cause-specific hazards and
also for the hazard of censoring (specified in the =estimation=
argument, with list elements for each hazard). This means that the Cox
model is misspecified for the cause-1 specific hazard. To estimate the
probability distribution of treatment (specified in the argument
=treat.model=), we similarly include main effects of all
covariates. To get the treatment-specific absolute risk of cancer
relapse under levamisole plus fluorouracil treatment we set the
argument =treat.effect= to =Lev+5FU= and the argument =target= to
=1=. We specify the time-horizon by =tau= and note that the time
variable of the data is measured in days. \\

The function returns the initial (untargeted) estimate for the target
parameter, the Kaplan-Meier estimate and the targeted estimate along
with its standard error computed based on the efficient influence
function.


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.Lev5FU.3yrs <- 
     contmle(sim.colon.cr,  
             estimation=list("relapse"=list(fit="cox",
                                            model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                             "death"=list(fit="cox",
                                          model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                             "cens"=list(fit="cox",
                                         model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                             ),
             treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
             treat.effect="Lev+5FU",   
             output.km=TRUE,
             target=1,
             tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.Lev5FU.3yrs
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888


$tmle
$tmle$F1
         tau=1095.75
tmle.est 0.2778811  
tmle.se  0.02584953 
#+end_example

(Note that the function call produces a warning from fitting the Cox
model for the hazard of the censoring distribution because of the
variable =extent=). \\

Recall that the true value of this target parameter is:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
true.a2[(1:10)/2==3][[1]]["F1"]
#+END_SRC   

:       F1 
: 0.271716

Notice how the initial and the updated TMLE estimates each differ from
the true value; the initial estimator is biased due to the
misspecification of the cause-1 specific hazard, but this bias is
removed for the TMLE estimator due to its double robustness
properties.


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
(true.a0 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=0, tau=tt*365.25)))
(true.a1 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=1, tau=tt*365.25)))
(true.a2 <- sapply(3, function(tt) synthesize.colon.fun(fit.colon=fit.colon.cr, d=colon.cr, name.treat="rx", event.name="event", 
                                                        n=1e6, get.true.value=2, tau=tt*365.25)))   
#+END_SRC   

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-parameter-axis.pdf" :exports none  :session *R* :width 12 :height 1.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    
pdat <- rbind(data.table(init=c(fit.tmle.F1.Lev5FU.3yrs$init$F1["init.est",]), 
                         tmle=unlist(c(fit.tmle.F1.Lev5FU.3yrs$tmle$F1["tmle.est",])),
                         true=c(true.a2["F1",]), 
                         parameter=c("Psi[1]^a"), 
                         treat=2))
 
pdat.melt <- melt(pdat, id.vars=c("treat", "parameter"))

pdat.melt[, min:=min(value)*0.98, by=c("treat", "parameter")]
pdat.melt[, max:=max(value)*1.02, by=c("treat", "parameter")]

pdat.melt[variable=="true", variable:="true value"]
pdat.melt[variable=="init", variable:="initial estimate"]
pdat.melt[variable=="tmle", variable:="TMLE estimate"]

ggplot(pdat.melt[treat==2 & parameter=="Psi[1]^a"]) + 
    theme_void(base_size=25) +  
    ylim(1.95, 2.05) +  
    geom_segment(aes(x=min, xend=max, y=treat, yend=treat), arrow=arrow(length=unit(0.3, "cm"))) +   
    geom_text(aes(x=value, y=treat-0.03, label=round(value, 4)), size=5) + 
    geom_point(aes(x=value, y=treat), shape=3, size=4) +
    geom_text(aes(x=value, y=treat+0.03, label=variable), size=6.0) + 
    scale_shape_manual(values=c(1, 8, 9)) + 
    labs(shape="") +  
    theme(legend.position="bottom")   
#+END_SRC    


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F1.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=1,
            output.mat="init", 
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F1.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=1,
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC    

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-tmle-update-colon-cr.pdf" :exports none  :session *R* :width 12 :height 8.5 :cache yes
i <- 1 
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause=paste0("hat(Lambda)['1,n']", "~'['*'id'*'='*", i, "*']'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz2*fit.cox2]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause=paste0("hat(Lambda)['2,n']", "~'['*'id'*'='*", i, "*']'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         ##init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, surv.t]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         ##updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, surv.t]),
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause=paste0("hat(S)['n']", "~'[population average]'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time]), 
                         ##init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, F1.t]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]), 
                         ##updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, F1.t]),
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause=paste0("hat(F)['1,n']", "~'[population average]'"), 
                         parameter=c(rep("'updated'~'for'~Psi['1,t'[0]]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])))))

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause")) 

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"] 

pdat.melt[, cause.factor:=factor(cause, ordered=TRUE, levels=pdat.melt[, unique(cause)])]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          axis.text=element_text(size=12),
          legend.key.size=unit(3,"line")) + 
    ylab("") + 
    xlab("time (days)") +  
    labs(linetype="") + 
    facet_wrap(. ~ cause.factor, labeller=label_parsed, scales="free_y") + 
    geom_line(aes(x=time, y=value, linetype=variable))    
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Targeting hazard estimators for multivariate parameter

We here show the code to apply our TMLE function to target the
multivariate parameter being the absolute risk of cancer relapse /and/
the absolute risk of relapse-free death after 3 years of follow-up
under treatment with levamisole plus fluorouracil. \\

The only change to the function call above is setting the argument
=target= to =1:2=. (When the argument =target= is multivariate, like
here, the one-step TMLE is applied per default; one could also specify
the argument =iterative= as =TRUE= to apply the iterative TMLE to
target the two absolute risk probabilities separately).

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            simultaneous.ci=TRUE,
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs 
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074

$init$F2
         tau=1095.75
init.est 0.012503259
init.se  0.007945622

$init$S
         tau=1095.75
init.est  0.68144137
init.se   0.02669174


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888

$km$F2
       tau=1095.75
km.est 0.014511430
km.se  0.007204259


$tmle
$tmle$F1
         tau=1095.75
tmle.est  0.27774955
tmle.se   0.02584448

$tmle$F2
         tau=1095.75
tmle.est 0.014375801
tmle.se  0.007923176

$tmle$S
         tau=1095.75
tmle.est  0.70787465
tmle.se   0.02660447


$convergenced.at.step
[1] 10

$q.max.95
     95% 
1.963704
#+end_example

The number found by =q.max.95= in the output is the 95% quantile used
to compute simultaneous confidence intervals. Notice that here this
number is very close to 1.96, so there will not be much difference
between the simultaneous and the marginal confidence intervals. \\

There are different technical options to how to run the one-step TMLE,
corresponding to different versions of weighted norms. Above we used
the unweighted norm (which is default), but if we instead specify the
argument =weighted.norm= as =Sigma=, we use the covariance weighted
norm which often leads to much faster convergence:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
fit.tmle.F1.F2.Lev5FU.3yrs  
#+END_SRC   

#+begin_example
$init
$init$F1
         tau=1095.75
init.est  0.30605538
init.se   0.02594074

$init$F2
         tau=1095.75
init.est 0.012503259
init.se  0.007945622

$init$S
         tau=1095.75
init.est  0.68144137
init.se   0.02669174


$km
$km$F1
       tau=1095.75
km.est  0.29184130
km.se   0.02732888

$km$F2
       tau=1095.75
km.est 0.014511430
km.se  0.007204259


$tmle
$tmle$F1
         tau=1095.75
tmle.est  0.27905720
tmle.se   0.02584936

$tmle$F2
         tau=1095.75
tmle.est  0.01516394
tmle.se   0.00791143

$tmle$S
         tau=1095.75
tmle.est  0.70577886
tmle.se   0.02660989


$convergenced.at.step
[1] 5

$q.max.95
     95% 
1.963361
#+end_example

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=2,
            output.mat="init", 
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE,
            target=2,
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
init.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            output.mat="init",
            tau=3*365.25) 
#+END_SRC   

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
updated.F1.F2.Lev5FU.3yrs <- 
    contmle(sim.colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",   
            output.km=TRUE, 
            target=1:2, 
            output.mat="updated",
            tau=3*365.25) 
#+END_SRC  

#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-update-colon-cr-treat2.pdf" :exports none  :session *R* :width 12 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   

i <- 1
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz1*fit.cox1],
                                       init.F2.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)],
                                             updated.F2.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause="hat(Lambda)['1,n']", 
                         parameter=c(rep("hat(Lambda)['1,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(Lambda)['1,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[id==i, chaz2*fit.cox2],
                                       init.F2.Lev5FU.3yrs[id==i, chaz2*fit.cox2]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)],
                                             updated.F2.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause="hat(Lambda)['2,n']", 
                         parameter=c(rep("hat(Lambda)['2,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(Lambda)['2,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))))

pdat[, parameter:=paste0(parameter, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

rev.fun <- function(var) sapply(strsplit(var, ""), function(x) paste0(rev(x), collapse=""))

pdat.melt[, parameter.factor:=factor(parameter, ordered=TRUE, levels=rev.fun(sort(rev.fun(pdat.melt[, unique(parameter)]))))]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"), 
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(parameter.factor ~ ., labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("Iterative TMLE applied for separate targeting:")  
#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-update-colon-cr-treat2.pdf" :exports none  :session *R* :width 12 :height 3.9 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

i <- 1
pdat <- rbind(data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[id==i, chaz1*fit.cox1]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[id==i, cumsum(dhaz1*fit.cox1)]),
                         cause="hat(Lambda)['1,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[id==i, chaz2*fit.cox2]),  
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[id==i, cumsum(dhaz2*fit.cox2)]),
                         cause="hat(Lambda)['2,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))))

pdat[, cause:=paste0(cause, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(. ~ cause, labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("One-step TMLE applied for simultaneous targeting:")  
#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-iterative-tmle-update-colon-cr-treat2-averaged.pdf" :exports none  :session *R* :width 12 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   
 
i <- 1
pdat <- rbind(data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause="hat(S)['n']", 
                         parameter=c(rep("hat(S)['n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(S)['n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause="hat(F)['1,n']", 
                         parameter=c(rep("hat(F)['1,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(F)['1,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.Lev5FU.3yrs[id==i, time], init.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]],
                                       init.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),  
                         updated.Lambda.a2=c(updated.F1.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]],
                                             updated.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),
                         cause="hat(F)['2,n']", 
                         parameter=c(rep("hat(F)['2,n']~'updated'~'for'~Psi[1]^2*(P)", length(init.F1.Lev5FU.3yrs[id==i, time])),
                                     rep("hat(F)['2,n']~'updated'~'for'~Psi[2]^2*(P)", length(init.F2.Lev5FU.3yrs[id==i, time])))))

#pdat[, parameter:=paste0(parameter, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

rev.fun <- function(var) sapply(strsplit(var, ""), function(x) paste0(rev(x), collapse=""))

pdat.melt[, parameter.factor:=factor(parameter, ordered=TRUE, levels=rev.fun(sort(rev.fun(pdat.melt[, unique(parameter)]))))]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="bottom", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"), 
          strip.text.x=element_text(size=14),
          axis.text=element_text(size=12),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(parameter.factor ~ ., labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("Iterative TMLE applied for separate targeting:")  
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-update-colon-cr-treat2-averaged.pdf" :exports none  :session *R* :width 12 :height 3.9 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

i <- 1
pdat <- rbind(data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(surv.t), by="time"][[2]]),
                         cause="hat(S)['n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))),
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]),  
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(F1.t), by="time"][[2]]),
                         cause="hat(F)['1,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))), 
              data.table(time=c(init.F1.F2.Lev5FU.3yrs[id==i, time]), 
                         init.Lambda=c(init.F1.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]), 
                         updated.Lambda.a2=c(updated.F1.F2.Lev5FU.3yrs[, mean(F2.t), by="time"][[2]]),
                         cause="hat(F)['2,n']~'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", 
                         parameter=c(rep("'updated'~'for'~Psi[1]^2*(P)~'and'~Psi[2]^2*(P)", length(init.F1.F2.Lev5FU.3yrs[id==i, time])))))

#pdat[, cause:=paste0(cause, "~'('*'id'*'='*", i, "*')'")]

pdat.melt <- melt(pdat, id.vars=c("time", "parameter", "cause"))

pdat.melt[variable=="init.Lambda", variable:="initial"]
pdat.melt[variable=="updated.Lambda.a0", variable:="a=0"]
pdat.melt[variable=="updated.Lambda.a1", variable:="a=1"]
pdat.melt[variable=="updated.Lambda.a2", variable:="updated"]

ggplot(pdat.melt) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=16),
          legend.key.size=unit(3,"line"),
          strip.text.x=element_text(size=14),
          axis.text=element_text(size=12),
          plot.title=element_text(hjust=0.5, size=20)) + 
    ylab("") +  
    xlab("time (days)") +   
    labs(linetype="") + 
    facet_wrap(.~cause, labeller=label_parsed, scales="free") + 
    geom_line(aes(x=time, y=value, linetype=variable)) + 
    ggtitle("One-step TMLE applied for simultaneous targeting:")  
#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-illustrate-one-step-tmle-parameter-axis.pdf" :exports none  :session *R* :width 12 :height 1.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    
pdat <- rbind(data.table(init=c(fit.tmle.F1.F2.Lev5FU.3yrs$init$F1["init.est",]), 
                         tmle=unlist(c(fit.tmle.F1.F2.Lev5FU.3yrs$tmle$F1["tmle.est",])),
                         true=c(true.a2["F1",]), 
                         parameter=c("Psi[1]^a"),  
                         treat=2))
 
pdat.melt <- melt(pdat, id.vars=c("treat", "parameter"))

pdat.melt[, min:=min(value)*0.98, by=c("treat", "parameter")]
pdat.melt[, max:=max(value)*1.02, by=c("treat", "parameter")]

pdat.melt[variable=="true", variable:="true value"]
pdat.melt[variable=="init", variable:="initial estimate"]
pdat.melt[variable=="tmle", variable:="TMLE estimate"]

ggplot(pdat.melt[treat==2 & parameter=="Psi[1]^a"]) + 
    theme_void(base_size=25) +  
    ylim(1.95, 2.05) +  
    geom_segment(aes(x=min, xend=max, y=treat, yend=treat), arrow=arrow(length=unit(0.3, "cm"))) +   
    geom_text(aes(x=value, y=treat-0.03, label=round(value, 4)), size=5) + 
    geom_point(aes(x=value, y=treat), shape=3, size=4) +
    geom_text(aes(x=value, y=treat+0.03, label=variable), size=6.0) + 
    scale_shape_manual(values=c(1, 8, 9)) + 
    labs(shape="") +  
    theme(legend.position="bottom")   
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]





** Initial estimation for analysis of the =colon= data

Now we consider the actual colon data (and not the simulated
version). For initial estimation of cause-specific hazards in all the
following analyses, we use will a super learner consisting of the Cox
models specified above as well as a selection of different HAL
estimators.\\

Here we specify a large number of different Cox models by including
and excluding different combinations of both main effects of
covariates and also a selection of interactions between treatment and
covariates:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results output :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))
head(sl.models)
#+END_SRC

#+begin_example
$cox.model.1
$cox.model.1[[1]]
Surv(time, event == 1) ~ rx
<environment: 0x55847c18b5a8>


$cox.model.2
$cox.model.2[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + surg + rx * age
<environment: 0x55847c24dba8>


$cox.model.3
$cox.model.3[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + surg + rx * sex
<environment: 0x55847cce1c58>


$cox.model.4
$cox.model.4[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + extent + rx * age + rx * sex
<environment: 0x55847cd0a798>


$cox.model.5
$cox.model.5[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + adhere + surg + rx * age + rx * sex
<environment: 0x55847cd2f068>


$cox.model.6
$cox.model.6[[1]]
Surv(time, event == 1) ~ rx + sex + nodes + age + obstruct + 
    perfor + differ + extent + surg + rx * age + rx * sex
<environment: 0x55847cd56bd0>
#+end_example

For the HAL estimators we first selected covariates and two-way
interactions with a pre-screening step which only included covariates
or interactions for which at least one of the basis functions was
given a non-zero coefficient. For initial estimation of the censoring
hazard we used simply the Cox super learner.

[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]


** Analysis of the =colon= survival data




#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))

cox.hal.sl.event.Lev5FU.surv.3yrs <-  
    contmle(colon.surv,  
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            tau=3*365.25)
cox.hal.sl.cens.Lev5FU.surv.3yrs <-  
    contmle(colon.surv,  
            estimation=list("outcome"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox.hal.sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            tau=3*365.25)
#+END_SRC


#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-surv-initial-estimation-event.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.event.Lev5FU.surv.3yrs)    

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("nodes included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("nodes excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("nodes excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("differ \n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("differ \n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[nodes==1, min.cve:=min.cve-1.2]
tune.grid[!nodes & !differ, min.cve:=min.cve-1]
tune.grid[!nodes & differ, min.cve:=min.cve-7.5]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="extent included"]
tune.grid[extent==0, extent.label:="extent excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("extent excluded",
    #                                                "extent included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+8, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+8), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    




*** Target parameters evaluated at fixed time-point 

We first consider TMLE estimation of the survival probabilities
evaluated after 3 years of follow-up: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.colon.surv.3yrs <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            treat.effect=treat,   
            output.km=TRUE, 
            tau=3*365.25)}) 
names(fit.colon.surv.3yrs) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.3yrs,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.3yrs", ".rds"))
#+END_SRC    

Treatment-specific survival probabilities: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
(fit.tmle <- do.call("cbind", lapply(1:length(fit.colon.surv.3yrs), function(jj) {
    fit.jj <- fit.colon.surv.3yrs[[jj]]
    out.jj <- fit.jj$tmle
    colnames(out.jj) <- names(fit.colon.surv.3yrs)[jj] 
    return(out.jj) 
}))) 
#+END_SRC    

:                 Lev    Lev+5FU        Obs
: tmle.est 0.36305673 0.25236697 0.33642019
: tmle.se  0.02658146 0.02523538 0.02552276

Average treatment effects: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
message("Lev versus Obs:")
rbind(est=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"], 
      se=sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.lwr=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"]-1.96*sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.upr=fit.tmle["tmle.est", "Lev"]-fit.tmle["tmle.est", "Obs"]+1.96*sqrt(fit.tmle["tmle.se", "Lev"]^2+fit.tmle["tmle.se", "Obs"]^2))
message("")
message("")
message("Lev+5FU versus Obs:")
rbind(est=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"],  
      se=sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.lwr=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"]-1.96*sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2), 
      ci.upr=fit.tmle["tmle.est", "Lev+5FU"]-fit.tmle["tmle.est", "Obs"]+1.96*sqrt(fit.tmle["tmle.se", "Lev+5FU"]^2+fit.tmle["tmle.se", "Obs"]^2)) 
#+END_SRC    

#+begin_example
Lev versus Obs:
 
             [,1]
est     0.02663654
se      0.03685085
ci.lwr -0.04559112
ci.upr  0.09886420


Lev+5FU versus Obs:
 
             [,1]
est    -0.08405322
se      0.03589200
ci.lwr -0.15440154
ci.upr -0.01370490
#+end_example



#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-fixed.pdf" :exports none  :session *R* :width 8 :height 2.8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- data.table(t(do.call("cbind", lapply(1:length(fit.colon.surv.3yrs), function(jj) {
    fit.jj <- fit.colon.surv.3yrs[[jj]] 
    out.jj <- fit.jj$tmle
    colnames(out.jj) <- names(fit.colon.surv.3yrs)[jj]  
    return(out.jj) 
}))))

pdat[, tmle.est:=1-tmle.est] 
pdat[, which:=names(fit.colon.surv.3yrs)]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, no:=1:.N]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,3.5),  
                       labels=unique(pdat$which)) +  
    xlab("TMLE estimate") + 
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-survival-fixed.pdf" :exports none  :session *R* :width 8 :height 2.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")    

pdat <- data.table(which=c("Lev vs Obs", "Lev+5FU vs Obs"),  
                   tmle.est=sapply(c("Lev", "Lev+5FU"), function(xx) fit.colon.surv.3yrs[[xx]]$tmle["tmle.est",] -  
                                                                     fit.colon.surv.3yrs[["Obs"]]$tmle["tmle.est",]), 
                   tmle.se=sapply(c("Lev", "Lev+5FU"), function(xx) sqrt(fit.colon.surv.3yrs[[xx]]$tmle["tmle.se",]^2 +   
                                                                         fit.colon.surv.3yrs[["Obs"]]$tmle["tmle.se",]^2)))

pdat[, tmle.est:=-tmle.est]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]  
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, no:=1:.N]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(),  
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_vline(aes(xintercept=0), alpha=0.6, linetype="dotted") +  
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,2.5), 
                       labels=unique(pdat$which)) + 
    xlab("TMLE estimate") + 
    ggtitle("Average treatment effects") 
#+END_SRC    



[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Target parameters evaluated at multiple time-points 

We here consider TMLE estimation of the survival probabilities
evaluated at a grid of 50 equidistant follow-up time-points.

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code  :results none  :session *R* :cache yes 
fit.colon.surv.50 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            verbose=TRUE,
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            output.km=TRUE, 
            tau=(1:50)/(5*2)*365.25)}) 
names(fit.colon.surv.50) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.50,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.50", "-Sigma", ".rds"))
#+END_SRC    


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.colon.surv.30 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            verbose=TRUE,
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            output.km=TRUE, 
            tau=(1:30)/(3*2)*365.25)}) 
names(fit.colon.surv.30) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.30,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.30", "-Sigma", ".rds"))
#+END_SRC    

Look at the output from the function call: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.colon.surv.30    
#+END_SRC    

#+begin_example
$Lev
$Lev$init
          tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
init.est 0.006101782 0.009762026  0.02811661 0.04531816  0.06741160 0.09191717  0.11647506 0.14603331  0.15965864
init.se  0.005100677 0.005848536  0.01096702 0.01432450  0.01510946 0.01752515  0.01895422 0.02033914  0.02084436
         tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125   tau=974 tau=1034.875 tau=1095.75
init.est 0.18955425  0.21192242 0.24411526  0.26507495 0.28108877  0.30321037 0.3290493   0.34128400  0.35227630
init.se  0.02203085  0.02299912 0.02416896  0.02467619 0.02495078  0.02546944 0.0260549   0.02626931  0.02659269
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125  tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
init.est   0.37053525 0.38991932   0.40201891  0.41532400   0.42253442 0.4321129   0.43809426   0.4428795   0.44645994
init.se    0.02677801 0.02704219   0.02700035  0.02735187   0.02735494 0.0274059   0.02737407   0.0274811   0.02748317
         tau=1704.5 tau=1765.375 tau=1826.25
init.est 0.45360578   0.45838172   0.4691711
init.se  0.02757524   0.02753867   0.0275061

$Lev$km
        tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
km.est 0.006802721 0.010204082  0.03401361 0.05782313  0.06462585 0.09863946   0.1224490 0.14625850  0.15986395
km.se  0.004793861 0.005861194  0.01057154 0.01361267  0.01433911 0.01739005   0.0191179 0.02060868  0.02137354
       tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125   tau=974 tau=1034.875 tau=1095.75
km.est  0.1870748  0.21088435 0.24489796  0.26870748 0.28231293  0.30272109 0.3367347   0.35034014   0.3673469
km.se   0.0227436  0.02379134 0.02507967  0.02585305 0.02625181  0.02679483 0.0275622   0.02782366   0.0281156
       tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
km.est   0.39115646 0.41156463   0.41836735  0.42517007    0.4285714 0.43537415   0.43877551   0.4421976    0.4421976
km.se    0.02846128 0.02870085   0.02876932  0.02883217    0.0288615 0.02891599   0.02894115   0.0289663    0.0289663
       tau=1704.5 tau=1765.375 tau=1826.25
km.est 0.44561971   0.44904181  0.45246391
km.se  0.02899003   0.02901235  0.02903328

$Lev$tmle
          tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
tmle.est 0.007266477 0.010203087  0.03553981 0.06101284  0.06890687 0.10077904  0.12365443 0.14714319  0.15995964
tmle.se  0.005099142 0.005848294  0.01092719 0.01427603  0.01507930 0.01742691  0.01883535 0.02021347  0.02069071
         tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
tmle.est  0.1866787  0.20962727 0.24349099  0.26492170 0.27841635  0.29777806 0.32935766   0.34270769  0.36025804
tmle.se   0.0218595  0.02284774 0.02396786  0.02446088 0.02470294  0.02525032 0.02581877   0.02602771  0.02635371
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
tmle.est   0.38125963 0.40060618    0.4071293  0.41731082   0.42024919 0.42688203   0.42998215  0.43401684   0.43401684
tmle.se    0.02652599 0.02682005    0.0267559  0.02718766   0.02719425 0.02724841   0.02719964  0.02733091   0.02733091
         tau=1704.5 tau=1765.375 tau=1826.25
tmle.est 0.43744338   0.44059084  0.44403557
tmle.se  0.02743244   0.02737481  0.02730043

$Lev$convergenced.at.step
[1] 7

$Lev$q.max.95
     95% 
2.524604 


$`Lev+5FU`
$`Lev+5FU`$init
          tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
init.est 0.004325087 0.006924395  0.02001412 0.03236644  0.04835471 0.06625443  0.08437224 0.10642540  0.11668424
init.se  0.007165521 0.007742604  0.01090591 0.01084140  0.01502677 0.01657955  0.01707638 0.01877303  0.01927577
         tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
init.est 0.13940550  0.15660172 0.18165640  0.19816900 0.21089498  0.22863572 0.24960145   0.25962315  0.26868020
init.se  0.02063912  0.02199585 0.02284632  0.02312483 0.02375451  0.02446988 0.02469647   0.02526592  0.02529587
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
init.est    0.2838380 0.30008868   0.31031764  0.32164326   0.32781550 0.33605310   0.34121948  0.34536532    0.3484747
init.se     0.0258088 0.02625253   0.02655883  0.02695369   0.02734144 0.02756742   0.02777056  0.02785631    0.0279598
         tau=1704.5 tau=1765.375 tau=1826.25
init.est 0.35469940   0.35887397  0.36834746
init.se  0.02796016   0.02797365  0.02813599

$`Lev+5FU`$km
        tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
km.est 0.013840830 0.017301038  0.03114187 0.03114187  0.06574394 0.08304498   0.0899654 0.11418685  0.12456747
km.se  0.006872356 0.007670036  0.01021771 0.01021771  0.01457847 0.01623236   0.0168313 0.01870812  0.01942517
       tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
km.est 0.14878893  0.16955017 0.19031142   0.1972318 0.21453287  0.23529412 0.24221453   0.25259516  0.25259516
km.se  0.02093413  0.02207277 0.02309099   0.0234064 0.02414693  0.02495191 0.02520138   0.02555886  0.02555886
       tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
km.est   0.26297578  0.2733564   0.28373702  0.29415141   0.30458267 0.31506634   0.32560378   0.3291163    0.3396537
km.se    0.02589702  0.0262166   0.02651828  0.02680572   0.02707767 0.02733759   0.02758566   0.0276647    0.0278911
       tau=1704.5 tau=1765.375 tau=1826.25
km.est 0.34667867   0.35019115  0.36426047
km.se  0.02803325   0.02810172  0.02836012

$`Lev+5FU`$tmle
         tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
tmle.est 0.01202810 0.015000638  0.03076795 0.03077521  0.06280641 0.07994872  0.08750766 0.11227545  0.12154069
tmle.se  0.00714289 0.007724095  0.01083339 0.01083340  0.01494909 0.01657851  0.01710342 0.01868223  0.01920906
         tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
tmle.est 0.14572617  0.16785240 0.18874692  0.19642020 0.21275806  0.23176010 0.23792329   0.24952068  0.24952134
tmle.se  0.02056695  0.02197271 0.02283711  0.02312661 0.02376735  0.02452923 0.02474302   0.02535636  0.02535636
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
tmle.est    0.2620818 0.27384050   0.28529109  0.29691601   0.30722450 0.31662990   0.32668001   0.3299108    0.3384994
tmle.se     0.0258748 0.02630819   0.02662369  0.02703585   0.02746097 0.02769462   0.02792035   0.0280044    0.0281201
         tau=1704.5 tau=1765.375 tau=1826.25
tmle.est 0.34588514    0.3491323  0.36362369
tmle.se  0.02807853    0.0280859  0.02823879

$`Lev+5FU`$convergenced.at.step
[1] 10

$`Lev+5FU`$q.max.95
     95% 
2.492932 


$Obs
$Obs$init
           tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
init.est 0.0063630200 0.010178925 0.029302193 0.04720600  0.07017542 0.09561799  0.12107788 0.15167191  0.16575611
init.se  0.0003886119 0.003150977 0.006866511 0.01046931  0.01288671 0.01484047  0.01719615 0.01906838  0.01969303
         tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
init.est 0.19661679  0.21966899 0.25278814  0.27431336 0.29073898  0.31340014 0.33982551   0.35232124  0.36353875
init.se  0.02083812  0.02145004 0.02272439  0.02368569 0.02401971  0.02441296 0.02501987   0.02522116  0.02558631
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
init.est    0.3821522  0.4018854   0.41418847  0.42770442   0.43502338 0.44473980   0.45080357  0.45565273   0.45927980
init.se     0.0259554  0.0264067   0.02645427  0.02671092   0.02684486 0.02687773   0.02690295  0.02697275   0.02697966
         tau=1704.5 tau=1765.375 tau=1826.25
init.est 0.46651564   0.47134944  0.48226275
init.se  0.02704678   0.02704475  0.02720205

$Obs$km
       tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
km.est          0 0.003278689 0.016393443 0.03934426  0.05901639 0.07540984  0.11147541 0.14434825  0.15751213
km.se           0 0.003273309 0.007271029 0.01113204  0.01349359 0.01511954  0.01802081 0.02013038  0.02086899
       tau=608.75 tau=669.625  tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
km.est 0.18713084  0.20358568 0.23649536   0.2628231 0.27598698  0.29573279 0.32535151   0.33522441  0.34838829
km.se  0.02234902  0.02307634 0.02435665   0.0252328 0.02562629  0.02616458 0.02686241   0.02706732  0.02731988
       tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125   tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
km.est   0.36484313 0.38787990   0.40433475  0.42408056   0.43066249 0.44053540   0.44382636  0.45040830   0.45040830
km.se    0.02760327 0.02794166   0.02814289  0.02834098   0.02839666 0.02847059   0.02849268  0.02853308   0.02853308
       tau=1704.5 tau=1765.375 tau=1826.25
km.est  0.4602812    0.4668631  0.48006894
km.se   0.0285842    0.0286120  0.02865511

$Obs$tmle
           tau=60.875  tau=121.75 tau=182.625  tau=243.5 tau=304.375 tau=365.25 tau=426.125    tau=487 tau=547.875
tmle.est 1.212744e-17 0.003164284 0.015336741 0.03744137  0.05682111 0.07401839  0.10847734 0.14003734  0.15273107
tmle.se  4.564701e-18 0.003134679 0.006833998 0.01045176  0.01286085 0.01480593  0.01715919 0.01902247  0.01963677
         tau=608.75 tau=669.625 tau=730.5 tau=791.375 tau=852.25 tau=913.125    tau=974 tau=1034.875 tau=1095.75
tmle.est 0.18084042  0.19541794 0.2268910  0.25327566 0.26678326  0.28556673 0.31368404   0.32310381  0.33696255
tmle.se  0.02074923  0.02134433 0.0226149  0.02360619 0.02391539  0.02427126 0.02487292   0.02506088  0.02546004
         tau=1156.625 tau=1217.5 tau=1278.375 tau=1339.25 tau=1400.125  tau=1461 tau=1521.875 tau=1582.75 tau=1643.625
tmle.est   0.35419011  0.3784379    0.3940699  0.41492001   0.42145365 0.4314914   0.43473820  0.44166576   0.44166576
tmle.se    0.02583973  0.0263364    0.0263634  0.02664916   0.02679688 0.0268183   0.02683841  0.02691896   0.02691896
         tau=1704.5 tau=1765.375 tau=1826.25
tmle.est 0.45207716   0.45793259  0.47201261
tmle.se  0.02699812   0.02698987  0.02717358

$Obs$convergenced.at.step
[1] 8

$Obs$q.max.95
     95% 
2.568266
#+end_example


Above we used the one-step TMLE to ensure compatible estimation. Here
we instead use the iterative TMLE which targets the survival
probabilities for each time-point separately. We also output the
estimating equations estimates which, like the iterative TMLE
estimates, solve each efficient influence curve equation
separately. Again, this is thus not guaranteed to yield compatible
estimation of the full survival curve: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.colon.surv.iterative.50 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.surv, 
            estimation=list("outcome"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,   
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            iterative=TRUE,
            output.km=TRUE, output.ee=TRUE, 
            tau=(1:50)/(5*2)*365.25)}) 
names(fit.colon.surv.iterative.50) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.colon.surv.iterative.50,
        file=paste0(path.to.file, "/output/", "fit.colon.surv.50", "-iterative", ".rds"))
#+END_SRC    

We can check monotonicity of the curve estimated with the iterative
TMLE as follows. The rows in the output below are the time-points
where the survival curve was increasing from one time-point to the
next. (The amount that it is increasing is not large for these data,
but this should still illustrate the issue).

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$tmle) 
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,tmle.est)), by=which]
check.monotone[diff<0] 
#+END_SRC    

#+begin_example
 
            tmle.est            tmle.se which     time                diff
 1: 0.429853761293166 0.0274042876813724   Lev 1497.525 -0.0000289712240461
 2: 0.436917112674670 0.0274775035815274   Lev 1607.100 -0.0000173033928114
 3: 0.436874701782329 0.0274761623954313   Lev 1643.625 -0.0000424108923415
 4: 0.443300907572835 0.0275189259777731   Lev 1753.200 -0.0000897707783220
 5: 0.446409107974176 0.0274631029206613   Lev 1826.250 -0.0001964259722576
 6: 0.000000006871145 0.0000000007378397   Obs   73.050 -0.0000000008573657
 7: 0.000000005766241 0.0000000006434194   Obs  109.575 -0.0000000011049042
 8: 0.421308326187093 0.0268258321643754   Obs 1424.475 -0.0001410404809641
 9: 0.441525350772389 0.0269548108142467   Obs 1607.100 -0.0000422683431834
10: 0.441432896377600 0.0269536562228939   Obs 1643.625 -0.0000924543947891
#+end_example

The same way we can check monotonicity of the curve estimated by
solving the estimating equations as follows.

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$ee) 
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,ee.est)), by=which]
check.monotone[diff<0]  
#+END_SRC    

#+begin_example
 
      ee.est      ee.se   which     time             diff
 1: 0.4203540 0.02734683     Lev 1387.950 -0.0000168700225
 2: 0.4298671 0.02740596     Lev 1497.525 -0.0000171453550
 3: 0.4369452 0.02748160     Lev 1607.100 -0.0000060395264
 4: 0.4369331 0.02748317     Lev 1643.625 -0.0000121358970
 5: 0.4434427 0.02753867     Lev 1753.200 -0.0000186171679
 6: 0.4467549 0.02750610     Lev 1826.250 -0.0000461483690
 7: 0.2517751 0.02528099 Lev+5FU 1059.225 -0.0000057658421
 8: 0.2517717 0.02529587 Lev+5FU 1095.750 -0.0000034836950
 9: 0.2517661 0.02532295 Lev+5FU 1132.275 -0.0000055024833
10: 0.2978114 0.02695369 Lev+5FU 1351.425 -0.0000001621608
11: 0.3500704 0.02796207 Lev+5FU 1716.675 -0.0000025898928
#+end_example

If we check the one-step TMLE, we just see that it is --- as expected
--- monotone:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports both :results output  :session *R* :cache yes 
check.monotone <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]]
    out.jj <- t(fit.jj$tmle) 
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj], time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))
check.monotone[, diff:=diff(c(0,tmle.est)), by=which]
check.monotone[diff<0]  
#+END_SRC    

: Empty data.table (0 rows and 5 cols): tmle.est,tmle.se,which,time,diff


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-one-step.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]]
    out.jj <- t(fit.jj$tmle)
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=1-tmle.est]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se] 
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) +  
    theme_bw(base_size=25) +     
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    xlab("time (years)") +  
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-survival-one-step.pdf" :exports none  :session *R* :width 12 :height 4 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.50), function(jj) {
    fit.jj <- fit.colon.surv.50[[jj]] 
    out.jj <- t(fit.jj$tmle)
    return(data.table(out.jj, which=names(fit.colon.surv.50)[jj],
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=-tmle.est]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="time")

pdat[, q.95:=q.95.y] 
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]
pdat[, which:=which.x]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +      
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    geom_hline(aes(yintercept=0), alpha=0.6, linetype="dotted") +  
    xlab("time (years)") +  
    ggtitle("Average treatment effects")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-survival-estimating-equation.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- do.call("rbind", lapply(1:length(fit.colon.surv.iterative.50), function(jj) {
    fit.jj <- fit.colon.surv.iterative.50[[jj]]
    out.jj <- t(fit.jj$ee)
    return(data.table(out.jj, which=names(fit.colon.surv.iterative.50)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, ee.est:=1-ee.est]
pdat[, q.95:=1.96]
pdat[, ci.lwr:=ee.est-q.95*ee.se] 
pdat[, ci.upr:=ee.est+q.95*ee.se]

pdat[, time:=time/365.25]

pdat[, diff:=diff(c(0,ee.est)), by=which]
pdat[, monotone:=diff<=0]

pdat[which=="Lev+5FU", which:="Lev+fluo"]
#pdat[diff>0]

ggplot(pdat) + #[which=="Lev+5FU"]) +  
    #xlim(2.8, 3.2) + ylim(0.748, 0.7485) + 
    theme_bw(base_size=25) +     
    theme(axis.title.y=element_text(angle=90, size=20), 
          axis.title.x=element_text(size=20),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    #geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
    #            col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    geom_line(aes(x=time, y=ee.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=ee.est, shape=monotone, size=1-monotone)) + 
    guides(size=FALSE, shape=FALSE) + 
    scale_shape_manual("", values=c(8, 16)) +
    xlab("time (years)") +  
    ggtitle("Treatment-specific survival probabilities")
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

** Analysis of the =colon= competing risks data


#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none :session *R* :cache yes
sl.models <- c("rx", "sex", "nodes", "age", "obstruct", "perfor",
               "differ", "adhere", "extent", "surg",
               "rx*age", "rx*sex", "rx*perfor")
sl.models.grid <- expand.grid(lapply(1:length(sl.models), function(x) 0:1))
names(sl.models.grid) <- sl.models

sl.models.grid <- sl.models.grid[(1:nrow(sl.models.grid))[rowSums(sl.models.grid)>10 | (1:nrow(sl.models.grid))==2],]

sl.models <- lapply(1:min(Inf,nrow(sl.models.grid)), function(ii) {
    list(as.formula(paste0("Surv(time, event==1)~", paste0(na.omit(sapply(1:length(sl.models.grid), function(jj) {
        ifelse(sl.models.grid[ii, jj]==1, names(sl.models.grid)[jj], NA)
    })), collapse="+"))))})

names(sl.models) <- paste0("cox.model.", 1:length(sl.models))

cox.hal.sl.F1.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
cox.hal.sl.F2.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
cox.hal.sl.cens.Lev5FU.3yrs <-  
    contmle(colon.cr,  
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox.hal.sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect="Lev+5FU",  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            output.tune.grid=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            V=10,
            target=1,  
            tau=3*365.25)
#+END_SRC


#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cause1.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve-0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-4]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
tune.grid[, extent.pos.y:=mean(cve), by=c("extent", "nodes", "which")]
tune.grid[nodes==1, extent.pos.x:=min(xnum)-1.5, by=c("nodes", "which")]
tune.grid[nodes==0, extent.pos.x:=min(xnum)+3, by=c("nodes", "which")]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox" & extent==0],
               aes(x=xnum, y=cve, col=differ## , shape=extent.label
                   ), shape=9, size=3) +
    geom_point(data=tune.grid[which=="cox" & extent==1],
               aes(x=xnum, y=cve, col=differ## , shape=extent.label
                   ), shape=8, size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)## , 
                       ## labels=expression("cut.two.way=0", "cut.two.way=10", "cut.two.way=15",
                       ##                   "cut.two.way=5", L[7]~"excluded", L[7]~"included")
                       ) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text), parse=TRUE) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2), parse=TRUE) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("cross-validated error") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+8, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+8), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[which=="cox" & nodes==1],
               aes(x=extent.pos.x, y=extent.pos.y, label=extent.label), parse=TRUE) +
    geom_label(data=tune.grid[which=="cox" & nodes==0],
               aes(x=extent.pos.x-1, y=extent.pos.y, label=extent.label), hjust=0, parse=TRUE) +
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.145,.475),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    




#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cause2.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.F2.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve+0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-3.75]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+6, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+6), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    ylim(110, tune.grid[, max(max.cve)]+6) + 
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation-cens.pdf" :exports none  :session *R* :width 10 :height 6 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")             

tune.grid <- copy(cox.hal.sl.cens.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=c("which", "cut.two.way")] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1] 
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & !differ, min.cve:=min.cve-0.5]
tune.grid[!nodes & differ, min.cve:=min.cve-6]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
tune.grid[extent==1, extent.label:="L[7]~included"]
tune.grid[extent==0, extent.label:="L[7]~excluded"]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent.label), size=3) +
    #labs(shape="") + 
    scale_shape_manual("", values=c(1, 2, 5, 6, 9, 8)) +
    #scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
    #                                                "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve, shape=lab.text), size=3) +
    geom_line(data=tune.grid[which=="hal"],
              aes(x=xnum, y=cve, group=factor(cut.two.way))) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    #geom_label(data=tune.grid[idN==1 & which=="hal"],
    #           aes(x=xnum-1, y=cve, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & nodes],
               aes(xintercept=xnum+0.4),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N & !nodes],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+6.5, label="     HAL estimators     "), size=8, 
               fill="gray90", label.size=0.25) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=mean(pos.text)-0.1, y=mean(max.cve+6.5), label="              Cox models               "), 
               size=8, fill="gray90", label.size=0.25) +
    ylim(1120, tune.grid[, max(max.cve)]+6.5) + 
    theme(axis.title.x=element_text(size=16, hjust=0.2),
          axis.text=element_text(size=12),
          legend.position=c(.545,.235),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation2.pdf" :exports none  :session *R* :width 16 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")          

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)   

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", differ:=unlist(lapply(sl.models, function(x) "differ"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", differ:=0]
tune.grid[which=="cox", extent:=unlist(lapply(sl.models, function(x) "extent"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", extent:=0]
tune.grid[which!="cox", table(extent, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, differ)
tune.grid[, xnum:=as.numeric(1:.N), by=which] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & differ, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & differ, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "differ")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & differ, lab.text2:=paste0("L[6]~\n included")]
tune.grid[which=="cox" & !differ, lab.text2:=paste0("L[6]~\n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "differ")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & differ, min.cve:=min.cve-4]
tune.grid[!nodes & !differ, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=differ, shape=extent), size=3) +
    scale_shape_manual("", values=c(1, 2), labels=c("L[7]~excluded",
                                                    "L[7]~included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve), size=3) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+3, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    theme(axis.title.x=element_text(size=16, hjust=0.3),
          axis.text=element_text(size=12),
          legend.position=c(.875,.535),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    



#+BEGIN_SRC R :results graphics :file "./figures/fig-colon-cr-initial-estimation.pdf" :exports none  :session *R* :width 16 :height 8 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")          

tune.grid <- copy(cox.hal.sl.F1.Lev5FU.3yrs)  

tune.grid[which=="cox", nodes:=unlist(lapply(sl.models, function(x) "nodes"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", nodes:=0]
tune.grid[which=="cox", perfor:=unlist(lapply(sl.models, function(x) "perfor"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", perfor:=0]
tune.grid[which=="cox", rx.perfor:=unlist(lapply(sl.models, function(x) "rx*perfor"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
tune.grid[which!="cox", rx.perfor:=0]
tune.grid[which!="cox", table(rx.perfor, nodes)]
#tune.grid[which=="cox", nodes.squared:=unlist(lapply(sl.models, function(x) "nodes.squared"%in%gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]])))]
#tune.grid[which!="cox", nodes.squared:=0]
setorder(tune.grid, which, nodes, perfor)
tune.grid[, xnum:=as.numeric(1:.N), by=which] 
max.xnum.hal <- tune.grid[which=="hal", max(xnum)]
tune.grid[which=="cox", xnum:=xnum/20+max.xnum.hal+2]
tune.grid[which=="cox" & !nodes & perfor, xnum:=xnum+1]
tune.grid[which=="cox" & nodes, xnum:=xnum+3]
tune.grid[which=="cox" & nodes & perfor, xnum:=xnum+1]
tune.grid[, pos.text:=mean(xnum), by=c("which", "cut.two.way", "nodes")]
tune.grid[, pos.text2:=mean(xnum), by=c("which", "cut.two.way", "nodes", "perfor")]
tune.grid[, x:=factor(1:.N, levels=1:.N, labels=cut.one.way)]
#lapply(sl.models, function(x) gsub(" ", "", strsplit(strsplit(as.character(x), "~")[[1]][2], " \\+ ")[[1]]))
tune.grid[, idN:=1:.N, by=c("cut.two.way", "nodes")]
tune.grid[, N:=.N, by=c("cut.two.way", "nodes")]
tune.grid[which=="hal", lab.text:=paste0("cut.two.way=", cut.two.way)]
tune.grid[which=="cox" & nodes, lab.text:=paste0("L[3]~ included")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & !nodes, lab.text:=paste0("L[3]~ excluded")]
tune.grid[which=="cox" & perfor, lab.text2:=paste0("perfor \n included")]
tune.grid[which=="cox" & !perfor, lab.text2:=paste0("perfor \n excluded")]
tune.grid[, idN2:=1:.N, by=c("cut.two.way", "nodes", "perfor")]
tune.grid[, N2:=.N, by=c("cut.two.way", "nodes", "perfor")]
tune.grid[, max.cve:=max(cve)]
tune.grid[, min.cve:=min(cve), by=c("which", "nodes")]
tune.grid[!nodes & perfor, min.cve:=min.cve-4]
tune.grid[!nodes & !perfor, pos.text2:=pos.text2+0.15]
min.pos.text <- tune.grid[which=="hal", min(pos.text)]
ggplot(tune.grid) +
    theme_bw(base_size=25) +
    geom_point(data=tune.grid[which=="cox"],
               aes(x=xnum, y=cve, col=perfor, shape=rx.perfor), size=3) +
    scale_shape_manual("", values=c(1, 2), labels=c("rx*perfor excluded",
                                                    "rx*perfor included")) +
    geom_point(data=tune.grid[which=="hal"],
               aes(x=xnum, y=cve), size=3) +
    geom_label(data=tune.grid[idN==1 & which=="cox"],
               aes(x=pos.text-0.5, y=max.cve+3, label=lab.text)) +
    geom_label(data=tune.grid[idN2==1 & which=="cox"],
               aes(x=pos.text2, y=min.cve-3, label=lab.text2)) +
    geom_label(data=tune.grid[idN==1 & which=="hal"],
               aes(x=pos.text, y=max.cve+3, label=lab.text)) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=pos.text+min.pos.text-0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="hal"],
               aes(xintercept=0.5),
               linetype="dashed", alpha=0.4) +
    geom_vline(data=tune.grid[which=="cox" & idN==N],
               aes(xintercept=xnum+1),
               linetype="dashed", alpha=0.4) +
    scale_color_manual(values=c("gray13", "gray56"), guide="none") + 
    xlab("cut.one.way") + ylab("CVE") + 
    theme(axis.title.x=element_text(size=16, hjust=0.3),
          axis.text=element_text(size=12),
          legend.position=c(.875,.535),
          legend.text=element_text(size=12), 
          legend.background=element_rect(fill='transparent')) + 
    scale_x_continuous(breaks=tune.grid[which=="hal"]$xnum, 
                       labels=tune.grid[which=="hal"]$cut.one.way) 

#+END_SRC    


*** Target parameters evaluated at fixed time-point

We first consider TMLE estimation of all state occupation
probabilities evaluated after 3 years of follow-up:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.contmle.F1.F2.3yrs <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, 
            output.km=TRUE, 
            simultaneous.ci=TRUE,
            target=1:2, 
            tau=3*365.25)}) 
names(fit.contmle.F1.F2.3yrs) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.F2.3yrs,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.F2.3yrs", ".rds"))
#+END_SRC    



#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.contmle.F1.F2.5 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE,
            output.km=TRUE, 
            weighted.norm="Sigma", 
            simultaneous.ci=TRUE,
            target=1:2, 
            tau=(1:5)*365.25)}) 
names(fit.contmle.F1.F2.5) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.F2.5,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.F2.5", ".rds"))
#+END_SRC    


Look at the output from the function call: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.contmle.F1.F2.3yrs 
#+END_SRC    

#+begin_example
$Lev
$Lev$init
$Lev$init$F1
         tau=1095.75
init.est  0.48926006
init.se   0.02836712

$Lev$init$F2
         tau=1095.75
init.est 0.015357277
init.se  0.007613289

$Lev$init$S
         tau=1095.75
init.est  0.49538266
init.se   0.02843236


$Lev$km
$Lev$km$F1
       tau=1095.75
km.est  0.47619048
km.se   0.02912751

$Lev$km$F2
       tau=1095.75
km.est 0.020408163
km.se  0.008246143


$Lev$tmle
$Lev$tmle$F1
         tau=1095.75
tmle.est  0.47748809
tmle.se   0.02835463

$Lev$tmle$F2
         tau=1095.75
tmle.est 0.017613508
tmle.se  0.007595705

$Lev$tmle$S
         tau=1095.75
tmle.est  0.50489840
tmle.se   0.02843068


$Lev$convergenced.at.step
[1] 14

$Lev$q.max.95
    95% 
1.96621 


$`Lev+5FU`
$`Lev+5FU`$init
$`Lev+5FU`$init$F1
         tau=1095.75
init.est  0.33816943
init.se   0.02751093

$`Lev+5FU`$init$F2
         tau=1095.75
init.est 0.025097429
init.se  0.008617509

$`Lev+5FU`$init$S
         tau=1095.75
init.est  0.63673314
init.se   0.02796726


$`Lev+5FU`$km
$`Lev+5FU`$km$F1
       tau=1095.75
km.est  0.33564014
km.se   0.02777728

$`Lev+5FU`$km$F2
       tau=1095.75
km.est 0.024221453
km.se  0.009043297


$`Lev+5FU`$tmle
$`Lev+5FU`$tmle$F1
         tau=1095.75
tmle.est   0.3352188
tmle.se    0.0275060

$`Lev+5FU`$tmle$F2
         tau=1095.75
tmle.est 0.023659105
tmle.se  0.008619622

$`Lev+5FU`$tmle$S
         tau=1095.75
tmle.est  0.64112211
tmle.se   0.02796174


$`Lev+5FU`$convergenced.at.step
[1] 8

$`Lev+5FU`$q.max.95
     95% 
1.964605 


$Obs
$Obs$init
$Obs$init$F1
         tau=1095.75
init.est  0.49721013
init.se   0.02758601

$Obs$init$F2
         tau=1095.75
init.est  0.02406588
init.se   0.00713911

$Obs$init$S
         tau=1095.75
init.est  0.47872399
init.se   0.02757703


$Obs$km
$Obs$km$F1
       tau=1095.75
km.est  0.48932819
km.se   0.02865829

$Obs$km$F2
       tau=1095.75
km.est 0.019752491
km.se  0.007983817


$Obs$tmle
$Obs$tmle$F1
         tau=1095.75
tmle.est  0.48104591
tmle.se   0.02755615

$Obs$tmle$F2
         tau=1095.75
tmle.est 0.020286726
tmle.se  0.007138789

$Obs$tmle$S
         tau=1095.75
tmle.est  0.49866736
tmle.se   0.02752291


$Obs$convergenced.at.step
[1] 12

$Obs$q.max.95
     95% 
1.967607
#+end_example


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-competing-risks-fixed.pdf" :exports none  :session *R* :width 12 :height 3.3 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")       

pdat <- data.table(do.call("rbind", lapply(1:length(fit.contmle.F1.F2.3yrs), function(jj) {
    fit.jj <- fit.contmle.F1.F2.3yrs[[jj]]
    out.jj <- do.call("cbind", fit.jj$tmle)
    colnames(out.jj) <- names(fit.jj$tmle) 
    return(data.table(t(out.jj), parameter=colnames(out.jj),
                      q.95=fit.jj$q.max.95, which=names(fit.contmle.F1.F2.3yrs)[jj])) 
})))

pdat[parameter=="F1", parameter:="F[1]"] 
pdat[parameter=="F2", parameter:="F[2]"]

pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]
pdat[, no:=as.numeric(factor(which, levels=unique(which)))]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          axis.text.x=element_text(size=12),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(), 
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,3.5),  
                       labels=unique(pdat$which)) +   
    facet_grid(. ~ parameter, scales="free", labeller=label_parsed) + 
    xlab("TMLE estimate") +  
    ggtitle("Treatment-specific absolute risk probabilities")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-competing-risks-fixed.pdf" :exports none  :session *R* :width 12 :height 3.0 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")     

pdat <- data.table(do.call("rbind", lapply(1:length(fit.contmle.F1.F2.3yrs), function(jj) {
    fit.jj <- fit.contmle.F1.F2.3yrs[[jj]] 
    out.jj <- do.call("cbind", fit.jj$tmle)
    colnames(out.jj) <- names(fit.jj$tmle)
    return(data.table(t(out.jj), parameter=colnames(out.jj), 
                      q.95=fit.jj$q.max.95, which=names(fit.contmle.F1.F2.3yrs)[jj])) 
})))

pdat[parameter=="F1", parameter:="F[1]"]
pdat[parameter=="F2", parameter:="F[2]"]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="parameter")

pdat[, q.95:=q.95.y] 
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, ci.lwr:=tmle.est-1.96*tmle.se]
pdat[, ci.upr:=tmle.est+1.96*tmle.se]
pdat[, which:=which.x]
pdat[, no:=as.numeric(factor(which, levels=unique(which)))]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(legend.position="none", 
          axis.title.y=element_text(angle=0), 
          axis.title.x=element_text(size=22),
          axis.text.x=element_text(size=12),
          legend.key.size=unit(3,"line"), 
          panel.grid.major=element_blank(),  
          panel.grid.minor=element_blank(), 
          plot.title=element_text(size=18)) + 
    ylab("") + 
    geom_vline(aes(xintercept=0), alpha=0.6, linetype="dotted") +  
    geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_point(aes(x=tmle.est, y=no), size=2) + 
    scale_y_continuous("", unique(pdat$no), 
                       limits=c(0.5,2.5), 
                       labels=unique(pdat$which)) + 
    facet_grid(. ~ parameter, scales="free", labeller=label_parsed) + 
    xlab("TMLE estimate") + 
    ggtitle("Average treatment effects") 
#+END_SRC    



[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

*** Target parameters evaluated at multiple time-points 

We here consider TMLE estimation of the absolute risk of cancer
relapse evaluated at a grid of 10 equidistant follow-up time-points.

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports code :results none  :session *R* :cache yes 
fit.contmle.F1.10 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox.hal.sl",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox.hal.sl",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="sl",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE,
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            output.km=TRUE, 
            target=1, 
            tau=(1:10)/2*365.25)}) 
names(fit.contmle.F1.10) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.10,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.10", ".rds"))
#+END_SRC    

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports none :results none  :session *R* :cache yes 
fit.contmle.F1.20 <- lapply(list("Lev", "Lev+5FU", "Obs"), function(treat) {
    contmle(colon.cr, 
            estimation=list("relapse"=list(fit="cox",
                                           model=Surv(time, event==1)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "death"=list(fit="cox",
                                         model=Surv(time, event==2)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg),
                            "cens"=list(fit="cox",
                                        model=Surv(time, event==0)~rx+sex+nodes+age+obstruct+perfor+differ+adhere+extent+surg)
                            ),
            treat.model=rx~sex+age+nodes+obstruct+perfor+differ+adhere+extent+surg,
            treat.effect=treat,  
            hal.sl=TRUE,
            sl.models=sl.models, verbose.sl=TRUE,
            cut.one.way.grid=ceiling(seq(5, 20, length=8)), 
            cut.two.way.grid=ceiling(seq(0, 15, length=4)), 
            verbose.hal=TRUE, verbose=TRUE, 
            simultaneous.ci=TRUE,
            weighted.norm="Sigma", 
            output.km=TRUE, 
            target=1, 
            tau=(1:20)/(2*2)*365.25)}) 
names(fit.contmle.F1.20) <- c("Lev", "Lev+5FU", "Obs")
saveRDS(fit.contmle.F1.20,
        file=paste0(path.to.file, "/output/", "fit.contmle.F1.20", ".rds"))
#+END_SRC    


Look at the output from the function call: 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R :exports results :results output  :session *R* :cache yes 
fit.contmle.F1.10 
#+END_SRC    

#+begin_example
$Lev
$Lev$init
$Lev$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est   0.1167954 0.26540994   0.3648577 0.43127963  0.45977603  0.48926006   0.50750214 0.51722828   0.53060030
init.se    0.0193665 0.02547524   0.0270024 0.02776233  0.02802278  0.02836688   0.02843318 0.02845304   0.02846771
         tau=1826.25
init.est   0.5415107
init.se    0.0285176


$Lev$km
$Lev$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est   0.1224490 0.27210884  0.36054422 0.42517007  0.44897959  0.47619048   0.49319728 0.49659864   0.51712915
km.se    0.0191179 0.02595559  0.02800341 0.02883217  0.02900838  0.02912751   0.02915789 0.02915992   0.02915041
       tau=1826.25
km.est   0.5239808
km.se    0.0291366


$Lev$tmle
$Lev$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.12552921 0.27628375  0.36203677 0.42573888  0.45118075  0.47734425   0.49316313 0.50103274    0.5165852
tmle.se   0.01934004 0.02541927  0.02697648 0.02773627  0.02800323  0.02834991   0.02841354 0.02842329    0.0284535
         tau=1826.25
tmle.est  0.52678316
tmle.se   0.02849799


$Lev$convergenced.at.step
[1] 101

$Lev$q.max.95
     95% 
2.222829 


$`Lev+5FU`
$`Lev+5FU`$init
$`Lev+5FU`$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.07217484 0.17091586  0.24205926 0.29230580  0.31460552  0.33816943   0.35302632 0.36103308   0.37214707
init.se   0.01402459 0.02049811  0.02421574 0.02622656  0.02668265  0.02751099   0.02775695 0.02783808   0.02788941
         tau=1826.25
init.est  0.38130539
init.se   0.02809854


$`Lev+5FU`$km
$`Lev+5FU`$km$F1
       tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.05882353 0.14878893  0.23183391 0.29065744  0.30795848  0.33564014   0.35294118 0.35642071   0.35993979
km.se   0.01384083 0.02093413  0.02482373 0.02670975  0.02715584  0.02777728   0.02811086 0.02817422   0.02823908
       tau=1826.25
km.est  0.37753519
km.se   0.02853805


$`Lev+5FU`$tmle
$`Lev+5FU`$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.06029411 0.14809761   0.2297420 0.28738558  0.30585282   0.3344838   0.34996950 0.35467146   0.36090199
tmle.se   0.01403929 0.02046458   0.0242083 0.02622643  0.02667109   0.0275110   0.02775821 0.02783342   0.02786805
         tau=1826.25
tmle.est  0.37554211
tmle.se   0.02810211


$`Lev+5FU`$convergenced.at.step
[1] 200

$`Lev+5FU`$q.max.95
     95% 
2.226305 


$Obs
$Obs$init
$Obs$init$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
init.est  0.11999158 0.27176466  0.37247248 0.43930424  0.46783411   0.4972101   0.51533146 0.52496637    0.5381880
init.se   0.01843779 0.02438973  0.02636525 0.02707843  0.02740829   0.0275867   0.02776279 0.02771404    0.0277523
         tau=1826.25
init.est  0.54895145
init.se   0.02777321


$Obs$km
$Obs$km$F1
       tau=182.625 tau=365.25 tau=547.875 tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
km.est  0.12786885 0.27868852  0.37071681 0.4267277  0.46297011  0.48932819   0.50580199 0.52557056   0.53874960
km.se   0.01912156 0.02567267  0.02766879 0.0283454  0.02858221  0.02865829   0.02866512 0.02863202   0.02858486
       tau=1826.25
km.est  0.54533912
km.se   0.02855372


$Obs$tmle
$Obs$tmle$F1
         tau=182.625 tau=365.25 tau=547.875  tau=730.5 tau=913.125 tau=1095.75 tau=1278.375   tau=1461 tau=1643.625
tmle.est  0.12491865 0.27026894   0.3596506 0.41818869  0.45121671  0.48037609   0.50003182 0.51422788   0.52856677
tmle.se   0.01843008 0.02437708   0.0263408 0.02703093  0.02738051  0.02755775   0.02773445 0.02770405   0.02774293
         tau=1826.25
tmle.est  0.53814667
tmle.se   0.02775702


$Obs$convergenced.at.step
[1] 85

$Obs$q.max.95
     95% 
2.238037
#+end_example

#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-colon-competing-risks-F1-10.pdf" :exports none  :session *R* :width 12 :height 4.5 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")      

pdat <- do.call("rbind", lapply(1:length(fit.contmle.F1.10), function(jj) {
    fit.jj <- fit.contmle.F1.10[[jj]]
    out.jj <- t(fit.jj$tmle$F1)
    return(data.table(out.jj, which=names(fit.contmle.F1.10)[jj], 
                      q.95=fit.jj$q.max.95, 
                      time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat <- merge(pdat, data.table(q.max.95=unlist(lapply(fit.contmle.F1.10, function(x) x$q.max.95)), 
                               which=names(fit.contmle.F1.10)), by="which")

pdat[, tmle.est:=tmle.est]
pdat[, ci.lwr:=tmle.est-q.95*tmle.se] 
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +     
    theme(#legend.position="bottom", 
        axis.title.y=element_text(angle=90, size=20), 
        axis.title.x=element_text(size=20),
        legend.key.size=unit(3,"line"), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    #geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    #scale_y_continuous("", unique(pdat$no),    
    #                   limits=c(0.5,3.5), 
    #                   labels=unique(pdat$which)) +   
    xlab("time (years)") +   
    ggtitle("Treatment-specific absolute risk of cancer relapse")
#+END_SRC    


#+BEGIN_SRC R :results graphics :file "./figures/fig-tmle-results-ate-colon-competing-risks-F1-10.pdf" :exports none  :session *R* :width 12 :height 4 :cache yes
setwd("~/research/TMLE-from-2020june/survival-baseline/worg/lifetime/")   

pdat <- do.call("rbind", lapply(1:length(fit.contmle.F1.10), function(jj) {
    fit.jj <- fit.contmle.F1.10[[jj]]
    out.jj <- t(fit.jj$tmle$F1)
    return(data.table(out.jj, which=names(fit.contmle.F1.10)[jj], 
                      q.95=fit.jj$q.max.95, time=as.numeric(gsub("tau\\=", "", rownames(out.jj)))))
}))

pdat[, tmle.est:=tmle.est]

pdat <- merge(pdat[which!="Obs"], pdat[which=="Obs"], by="time")
pdat[, q.95:=q.95.y]  
pdat[q.95.y<=q.95.x, q.95:=q.95.x] 

pdat[, tmle.est:=tmle.est.x-tmle.est.y]
pdat[, tmle.se:=sqrt(tmle.se.x^2+tmle.se.y^2)]
pdat[, which:=which.x]

pdat <- merge(pdat, data.table(q.max.95=unlist(lapply(fit.contmle.F1.10, function(x) x$q.max.95)), 
                               which=names(fit.contmle.F1.10)), by="which")

pdat[, ci.lwr:=tmle.est-q.95*tmle.se]
pdat[, ci.upr:=tmle.est+q.95*tmle.se]

pdat[, time:=time/365.25]

pdat[which=="Lev+5FU", which:="Lev+fluo"]

ggplot(pdat) + 
    theme_bw(base_size=25) +      
    theme(#legend.position="bottom", 
        axis.title.y=element_text(angle=90, size=20), 
        axis.title.x=element_text(size=20),
        legend.key.size=unit(3,"line"), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        plot.title=element_text(size=18)) + 
    ylab("TMLE estimate") +
    labs(linetype="") +  
    geom_ribbon(aes(x=time, ymin=ci.lwr, ymax=ci.upr, group=which, linetype=which), 
                col="gray60", fill="grey80", alpha=0.4, size=0.7) +  
    #geom_segment(aes(y=no, yend=no, x=ci.lwr, xend=ci.upr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.lwr, xend=ci.lwr), size=1) +  
    #geom_segment(aes(y=no-0.1, yend=no+0.1, x=ci.upr, xend=ci.upr), size=1) +  
    geom_line(aes(x=time, y=tmle.est, linetype=which), size=0.7) + 
    geom_point(aes(x=time, y=tmle.est), size=0.5) + 
    geom_hline(aes(yintercept=0), alpha=0.6, linetype="dotted") +  
    xlab("time (years)") +  
    ggtitle("Average treatment effects")
#+END_SRC    


[[https://github.com/helenecharlotte/Web-appendix-TMLE-causal-inference-survival-analysis][Back to top]]

* Dependencies :noexport:

** R-version

The code has been tested with the following R version

#+BEGIN_SRC R  :results output :exports results  :session *R* :cache yes  
version  
#+END_SRC

#+begin_example
               _                           
platform       x86_64-pc-linux-gnu         
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          4                           
minor          0.3                         
year           2020                        
month          10                          
day            10                          
svn rev        79318                       
language       R                           
version.string R version 4.0.3 (2020-10-10)
nickname       Bunny-Wunnies Freak Out
#+end_example

and the following package versions:

#+BEGIN_SRC R  :results output raw drawer  :exports results  :session *R* :cache yes  
pp <- c("data.table", "zoo", "glmnet", "stringr", "nleqslv", "prodlim", "ggplot2", "gridExtra", "survival", "riskRegression", "MASS", "hdnom")
Publish::org(data.table(Package=pp,Version=sapply(pp,function(x) as.character(packageVersion(x))))) 
#+END_SRC

#+RESULTS[<2021-10-26 13:12:32> 5277b86706f38c0f421795154abdeb26ccff69db]:
:RESULTS:
| Package        |    Version |
|----------------+------------|
| data.table     |     1.14.0 |
| zoo            |      1.8.9 |
| glmnet         |        4.1 |
| stringr        |      1.4.0 |
| nleqslv        |      3.3.2 |
| prodlim        | 2019.11.13 |
| ggplot2        |      3.3.5 |
| gridExtra      |        2.3 |
| survival       |      3.2.7 |
| riskRegression |  2021.6.30 |
| MASS           |     7.3.53 |
:END:
